import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.1.3
 * Query Engine version: 363f5a521d6b06543e53d134652a0037a3096d41
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray


/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export declare type TrueKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string, collectTimestamps?: any): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.categories.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.categories.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  connect(): Promise<void>;
  /**
   * @private
   */
  private runDisconnect;
  /**
   * Disconnect from the database
   */
  disconnect(): Promise<any>;

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): categoriesDelegate;

  /**
   * `prisma.customer_customer_demo`: Exposes CRUD operations for the **customer_customer_demo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_customer_demos
    * const customer_customer_demos = await prisma.customer_customer_demo.findMany()
    * ```
    */
  get customer_customer_demo(): customer_customer_demoDelegate;

  /**
   * `prisma.customer_demographics`: Exposes CRUD operations for the **customer_demographics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_demographics
    * const customer_demographics = await prisma.customer_demographics.findMany()
    * ```
    */
  get customer_demographics(): customer_demographicsDelegate;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): customersDelegate;

  /**
   * `prisma.employee_territories`: Exposes CRUD operations for the **employee_territories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_territories
    * const employee_territories = await prisma.employee_territories.findMany()
    * ```
    */
  get employee_territories(): employee_territoriesDelegate;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): employeesDelegate;

  /**
   * `prisma.order_details`: Exposes CRUD operations for the **order_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_details
    * const order_details = await prisma.order_details.findMany()
    * ```
    */
  get order_details(): order_detailsDelegate;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): ordersDelegate;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): productsDelegate;

  /**
   * `prisma.region`: Exposes CRUD operations for the **region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): regionDelegate;

  /**
   * `prisma.shippers`: Exposes CRUD operations for the **shippers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shippers
    * const shippers = await prisma.shippers.findMany()
    * ```
    */
  get shippers(): shippersDelegate;

  /**
   * `prisma.suppliers`: Exposes CRUD operations for the **suppliers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.suppliers.findMany()
    * ```
    */
  get suppliers(): suppliersDelegate;

  /**
   * `prisma.territories`: Exposes CRUD operations for the **territories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Territories
    * const territories = await prisma.territories.findMany()
    * ```
    */
  get territories(): territoriesDelegate;

  /**
   * `prisma.us_states`: Exposes CRUD operations for the **us_states** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Us_states
    * const us_states = await prisma.us_states.findMany()
    * ```
    */
  get us_states(): us_statesDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const OrderByArg: {
  asc: 'asc',
  desc: 'desc'
};

export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg]



/**
 * Model categories
 */

export type categories = {
  category_id: number
  category_name: string
  description: string | null
}

export type categoriesSelect = {
  category_id?: boolean
  category_name?: boolean
  description?: boolean
  products?: boolean | FindManyproductsArgs
}

export type categoriesInclude = {
  products?: boolean | FindManyproductsArgs
}

export type categoriesGetPayload<
  S extends boolean | null | undefined | categoriesArgs,
  U = keyof S
> = S extends true
  ? categories
  : S extends undefined
  ? never
  : S extends categoriesArgs | FindManycategoriesArgs
  ? 'include' extends U
    ? categories  & {
      [P in TrueKeys<S['include']>]:
      P extends 'products'
      ? Array<productsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof categories ? categories[P]
: 
      P extends 'products'
      ? Array<productsGetPayload<S['select'][P]>> : never
    }
  : categories
: categories


export interface categoriesDelegate {
  /**
   * Find zero or one Categories.
   * @param {FindOnecategoriesArgs} args - Arguments to find a Categories
   * @example
   * // Get one Categories
   * const categories = await prisma.categories.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnecategoriesArgs>(
    args: Subset<T, FindOnecategoriesArgs>
  ): CheckSelect<T, Prisma__categoriesClient<categories | null>, Prisma__categoriesClient<categoriesGetPayload<T> | null>>
  /**
   * Find zero or more Categories.
   * @param {FindManycategoriesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Categories
   * const categories = await prisma.categories.findMany()
   * 
   * // Get first 10 Categories
   * const categories = await prisma.categories.findMany({ take: 10 })
   * 
   * // Only select the `category_id`
   * const categoriesWithCategory_idOnly = await prisma.categories.findMany({ select: { category_id: true } })
   * 
  **/
  findMany<T extends FindManycategoriesArgs>(
    args?: Subset<T, FindManycategoriesArgs>
  ): CheckSelect<T, Promise<Array<categories>>, Promise<Array<categoriesGetPayload<T>>>>
  /**
   * Create a Categories.
   * @param {categoriesCreateArgs} args - Arguments to create a Categories.
   * @example
   * // Create one Categories
   * const Categories = await prisma.categories.create({
   *   data: {
   *     // ... data to create a Categories
   *   }
   * })
   * 
  **/
  create<T extends categoriesCreateArgs>(
    args: Subset<T, categoriesCreateArgs>
  ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>
  /**
   * Delete a Categories.
   * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
   * @example
   * // Delete one Categories
   * const Categories = await prisma.categories.delete({
   *   where: {
   *     // ... filter to delete one Categories
   *   }
   * })
   * 
  **/
  delete<T extends categoriesDeleteArgs>(
    args: Subset<T, categoriesDeleteArgs>
  ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>
  /**
   * Update one Categories.
   * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
   * @example
   * // Update one Categories
   * const categories = await prisma.categories.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends categoriesUpdateArgs>(
    args: Subset<T, categoriesUpdateArgs>
  ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>
  /**
   * Delete zero or more Categories.
   * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
   * @example
   * // Delete a few Categories
   * const { count } = await prisma.categories.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends categoriesDeleteManyArgs>(
    args: Subset<T, categoriesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Categories.
   * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Categories
   * const categories = await prisma.categories.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends categoriesUpdateManyArgs>(
    args: Subset<T, categoriesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Categories.
   * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
   * @example
   * // Update or create a Categories
   * const categories = await prisma.categories.upsert({
   *   create: {
   *     // ... data to create a Categories
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Categories we want to update
   *   }
   * })
  **/
  upsert<T extends categoriesUpsertArgs>(
    args: Subset<T, categoriesUpsertArgs>
  ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManycategoriesArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for categories.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__categoriesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  products<T extends FindManyproductsArgs = {}>(args?: Subset<T, FindManyproductsArgs>): CheckSelect<T, Promise<Array<products>>, Promise<Array<productsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * categories findOne
 */
export type FindOnecategoriesArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
  /**
   * Filter, which categories to fetch.
  **/
  where: categoriesWhereUniqueInput
}


/**
 * categories findMany
 */
export type FindManycategoriesArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
  /**
   * Filter, which categories to fetch.
  **/
  where?: categoriesWhereInput
  /**
   * Determine the order of the categories to fetch.
  **/
  orderBy?: categoriesOrderByInput
  /**
   * Sets the position for listing categories.
  **/
  cursor?: categoriesWhereUniqueInput
  /**
   * The number of categories to fetch. If negative number, it will take categories before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` categories.
  **/
  skip?: number
}


/**
 * categories create
 */
export type categoriesCreateArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
  /**
   * The data needed to create a categories.
  **/
  data: categoriesCreateInput
}


/**
 * categories update
 */
export type categoriesUpdateArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
  /**
   * The data needed to update a categories.
  **/
  data: categoriesUpdateInput
  /**
   * Choose, which categories to update.
  **/
  where: categoriesWhereUniqueInput
}


/**
 * categories updateMany
 */
export type categoriesUpdateManyArgs = {
  data: categoriesUpdateManyMutationInput
  where?: categoriesWhereInput
}


/**
 * categories upsert
 */
export type categoriesUpsertArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
  /**
   * The filter to search for the categories to update in case it exists.
  **/
  where: categoriesWhereUniqueInput
  /**
   * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
  **/
  create: categoriesCreateInput
  /**
   * In case the categories was found with the provided `where` argument, update it with this data.
  **/
  update: categoriesUpdateInput
}


/**
 * categories delete
 */
export type categoriesDeleteArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
  /**
   * Filter which categories to delete.
  **/
  where: categoriesWhereUniqueInput
}


/**
 * categories deleteMany
 */
export type categoriesDeleteManyArgs = {
  where?: categoriesWhereInput
}


/**
 * categories without action
 */
export type categoriesArgs = {
  /**
   * Select specific fields to fetch from the categories
  **/
  select?: categoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: categoriesInclude | null
}



/**
 * Model customer_customer_demo
 */

export type customer_customer_demo = {
  customer_id: string
  customer_type_id: string
}

export type customer_customer_demoSelect = {
  customer_id?: boolean
  customer_type_id?: boolean
  customers?: boolean | customersArgs
  customer_demographics?: boolean | customer_demographicsArgs
}

export type customer_customer_demoInclude = {
  customers?: boolean | customersArgs
  customer_demographics?: boolean | customer_demographicsArgs
}

export type customer_customer_demoGetPayload<
  S extends boolean | null | undefined | customer_customer_demoArgs,
  U = keyof S
> = S extends true
  ? customer_customer_demo
  : S extends undefined
  ? never
  : S extends customer_customer_demoArgs | FindManycustomer_customer_demoArgs
  ? 'include' extends U
    ? customer_customer_demo  & {
      [P in TrueKeys<S['include']>]:
      P extends 'customers'
      ? customersGetPayload<S['include'][P]> :
      P extends 'customer_demographics'
      ? customer_demographicsGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof customer_customer_demo ? customer_customer_demo[P]
: 
      P extends 'customers'
      ? customersGetPayload<S['select'][P]> :
      P extends 'customer_demographics'
      ? customer_demographicsGetPayload<S['select'][P]> : never
    }
  : customer_customer_demo
: customer_customer_demo


export interface customer_customer_demoDelegate {
  /**
   * Find zero or one Customer_customer_demo.
   * @param {FindOnecustomer_customer_demoArgs} args - Arguments to find a Customer_customer_demo
   * @example
   * // Get one Customer_customer_demo
   * const customer_customer_demo = await prisma.customer_customer_demo.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnecustomer_customer_demoArgs>(
    args: Subset<T, FindOnecustomer_customer_demoArgs>
  ): CheckSelect<T, Prisma__customer_customer_demoClient<customer_customer_demo | null>, Prisma__customer_customer_demoClient<customer_customer_demoGetPayload<T> | null>>
  /**
   * Find zero or more Customer_customer_demos.
   * @param {FindManycustomer_customer_demoArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Customer_customer_demos
   * const customer_customer_demos = await prisma.customer_customer_demo.findMany()
   * 
   * // Get first 10 Customer_customer_demos
   * const customer_customer_demos = await prisma.customer_customer_demo.findMany({ take: 10 })
   * 
   * // Only select the `customer_id`
   * const customer_customer_demoWithCustomer_idOnly = await prisma.customer_customer_demo.findMany({ select: { customer_id: true } })
   * 
  **/
  findMany<T extends FindManycustomer_customer_demoArgs>(
    args?: Subset<T, FindManycustomer_customer_demoArgs>
  ): CheckSelect<T, Promise<Array<customer_customer_demo>>, Promise<Array<customer_customer_demoGetPayload<T>>>>
  /**
   * Create a Customer_customer_demo.
   * @param {customer_customer_demoCreateArgs} args - Arguments to create a Customer_customer_demo.
   * @example
   * // Create one Customer_customer_demo
   * const Customer_customer_demo = await prisma.customer_customer_demo.create({
   *   data: {
   *     // ... data to create a Customer_customer_demo
   *   }
   * })
   * 
  **/
  create<T extends customer_customer_demoCreateArgs>(
    args: Subset<T, customer_customer_demoCreateArgs>
  ): CheckSelect<T, Prisma__customer_customer_demoClient<customer_customer_demo>, Prisma__customer_customer_demoClient<customer_customer_demoGetPayload<T>>>
  /**
   * Delete a Customer_customer_demo.
   * @param {customer_customer_demoDeleteArgs} args - Arguments to delete one Customer_customer_demo.
   * @example
   * // Delete one Customer_customer_demo
   * const Customer_customer_demo = await prisma.customer_customer_demo.delete({
   *   where: {
   *     // ... filter to delete one Customer_customer_demo
   *   }
   * })
   * 
  **/
  delete<T extends customer_customer_demoDeleteArgs>(
    args: Subset<T, customer_customer_demoDeleteArgs>
  ): CheckSelect<T, Prisma__customer_customer_demoClient<customer_customer_demo>, Prisma__customer_customer_demoClient<customer_customer_demoGetPayload<T>>>
  /**
   * Update one Customer_customer_demo.
   * @param {customer_customer_demoUpdateArgs} args - Arguments to update one Customer_customer_demo.
   * @example
   * // Update one Customer_customer_demo
   * const customer_customer_demo = await prisma.customer_customer_demo.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends customer_customer_demoUpdateArgs>(
    args: Subset<T, customer_customer_demoUpdateArgs>
  ): CheckSelect<T, Prisma__customer_customer_demoClient<customer_customer_demo>, Prisma__customer_customer_demoClient<customer_customer_demoGetPayload<T>>>
  /**
   * Delete zero or more Customer_customer_demos.
   * @param {customer_customer_demoDeleteManyArgs} args - Arguments to filter Customer_customer_demos to delete.
   * @example
   * // Delete a few Customer_customer_demos
   * const { count } = await prisma.customer_customer_demo.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends customer_customer_demoDeleteManyArgs>(
    args: Subset<T, customer_customer_demoDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Customer_customer_demos.
   * @param {customer_customer_demoUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Customer_customer_demos
   * const customer_customer_demo = await prisma.customer_customer_demo.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends customer_customer_demoUpdateManyArgs>(
    args: Subset<T, customer_customer_demoUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Customer_customer_demo.
   * @param {customer_customer_demoUpsertArgs} args - Arguments to update or create a Customer_customer_demo.
   * @example
   * // Update or create a Customer_customer_demo
   * const customer_customer_demo = await prisma.customer_customer_demo.upsert({
   *   create: {
   *     // ... data to create a Customer_customer_demo
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Customer_customer_demo we want to update
   *   }
   * })
  **/
  upsert<T extends customer_customer_demoUpsertArgs>(
    args: Subset<T, customer_customer_demoUpsertArgs>
  ): CheckSelect<T, Prisma__customer_customer_demoClient<customer_customer_demo>, Prisma__customer_customer_demoClient<customer_customer_demoGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManycustomer_customer_demoArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for customer_customer_demo.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__customer_customer_demoClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  customers<T extends customersArgs = {}>(args?: Subset<T, customersArgs>): CheckSelect<T, Prisma__customersClient<customers | null>, Prisma__customersClient<customersGetPayload<T> | null>>;

  customer_demographics<T extends customer_demographicsArgs = {}>(args?: Subset<T, customer_demographicsArgs>): CheckSelect<T, Prisma__customer_demographicsClient<customer_demographics | null>, Prisma__customer_demographicsClient<customer_demographicsGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * customer_customer_demo findOne
 */
export type FindOnecustomer_customer_demoArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
  /**
   * Filter, which customer_customer_demo to fetch.
  **/
  where: customer_customer_demoWhereUniqueInput
}


/**
 * customer_customer_demo findMany
 */
export type FindManycustomer_customer_demoArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
  /**
   * Filter, which customer_customer_demos to fetch.
  **/
  where?: customer_customer_demoWhereInput
  /**
   * Determine the order of the customer_customer_demos to fetch.
  **/
  orderBy?: customer_customer_demoOrderByInput
  /**
   * Sets the position for listing customer_customer_demos.
  **/
  cursor?: customer_customer_demoWhereUniqueInput
  /**
   * The number of customer_customer_demos to fetch. If negative number, it will take customer_customer_demos before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` customer_customer_demos.
  **/
  skip?: number
}


/**
 * customer_customer_demo create
 */
export type customer_customer_demoCreateArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
  /**
   * The data needed to create a customer_customer_demo.
  **/
  data: customer_customer_demoCreateInput
}


/**
 * customer_customer_demo update
 */
export type customer_customer_demoUpdateArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
  /**
   * The data needed to update a customer_customer_demo.
  **/
  data: customer_customer_demoUpdateInput
  /**
   * Choose, which customer_customer_demo to update.
  **/
  where: customer_customer_demoWhereUniqueInput
}


/**
 * customer_customer_demo updateMany
 */
export type customer_customer_demoUpdateManyArgs = {
  data: customer_customer_demoUpdateManyMutationInput
  where?: customer_customer_demoWhereInput
}


/**
 * customer_customer_demo upsert
 */
export type customer_customer_demoUpsertArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
  /**
   * The filter to search for the customer_customer_demo to update in case it exists.
  **/
  where: customer_customer_demoWhereUniqueInput
  /**
   * In case the customer_customer_demo found by the `where` argument doesn't exist, create a new customer_customer_demo with this data.
  **/
  create: customer_customer_demoCreateInput
  /**
   * In case the customer_customer_demo was found with the provided `where` argument, update it with this data.
  **/
  update: customer_customer_demoUpdateInput
}


/**
 * customer_customer_demo delete
 */
export type customer_customer_demoDeleteArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
  /**
   * Filter which customer_customer_demo to delete.
  **/
  where: customer_customer_demoWhereUniqueInput
}


/**
 * customer_customer_demo deleteMany
 */
export type customer_customer_demoDeleteManyArgs = {
  where?: customer_customer_demoWhereInput
}


/**
 * customer_customer_demo without action
 */
export type customer_customer_demoArgs = {
  /**
   * Select specific fields to fetch from the customer_customer_demo
  **/
  select?: customer_customer_demoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_customer_demoInclude | null
}



/**
 * Model customer_demographics
 */

export type customer_demographics = {
  customer_desc: string | null
  customer_type_id: string
}

export type customer_demographicsSelect = {
  customer_desc?: boolean
  customer_type_id?: boolean
  customer_customer_demo?: boolean | FindManycustomer_customer_demoArgs
}

export type customer_demographicsInclude = {
  customer_customer_demo?: boolean | FindManycustomer_customer_demoArgs
}

export type customer_demographicsGetPayload<
  S extends boolean | null | undefined | customer_demographicsArgs,
  U = keyof S
> = S extends true
  ? customer_demographics
  : S extends undefined
  ? never
  : S extends customer_demographicsArgs | FindManycustomer_demographicsArgs
  ? 'include' extends U
    ? customer_demographics  & {
      [P in TrueKeys<S['include']>]:
      P extends 'customer_customer_demo'
      ? Array<customer_customer_demoGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof customer_demographics ? customer_demographics[P]
: 
      P extends 'customer_customer_demo'
      ? Array<customer_customer_demoGetPayload<S['select'][P]>> : never
    }
  : customer_demographics
: customer_demographics


export interface customer_demographicsDelegate {
  /**
   * Find zero or one Customer_demographics.
   * @param {FindOnecustomer_demographicsArgs} args - Arguments to find a Customer_demographics
   * @example
   * // Get one Customer_demographics
   * const customer_demographics = await prisma.customer_demographics.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnecustomer_demographicsArgs>(
    args: Subset<T, FindOnecustomer_demographicsArgs>
  ): CheckSelect<T, Prisma__customer_demographicsClient<customer_demographics | null>, Prisma__customer_demographicsClient<customer_demographicsGetPayload<T> | null>>
  /**
   * Find zero or more Customer_demographics.
   * @param {FindManycustomer_demographicsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Customer_demographics
   * const customer_demographics = await prisma.customer_demographics.findMany()
   * 
   * // Get first 10 Customer_demographics
   * const customer_demographics = await prisma.customer_demographics.findMany({ take: 10 })
   * 
   * // Only select the `customer_desc`
   * const customer_demographicsWithCustomer_descOnly = await prisma.customer_demographics.findMany({ select: { customer_desc: true } })
   * 
  **/
  findMany<T extends FindManycustomer_demographicsArgs>(
    args?: Subset<T, FindManycustomer_demographicsArgs>
  ): CheckSelect<T, Promise<Array<customer_demographics>>, Promise<Array<customer_demographicsGetPayload<T>>>>
  /**
   * Create a Customer_demographics.
   * @param {customer_demographicsCreateArgs} args - Arguments to create a Customer_demographics.
   * @example
   * // Create one Customer_demographics
   * const Customer_demographics = await prisma.customer_demographics.create({
   *   data: {
   *     // ... data to create a Customer_demographics
   *   }
   * })
   * 
  **/
  create<T extends customer_demographicsCreateArgs>(
    args: Subset<T, customer_demographicsCreateArgs>
  ): CheckSelect<T, Prisma__customer_demographicsClient<customer_demographics>, Prisma__customer_demographicsClient<customer_demographicsGetPayload<T>>>
  /**
   * Delete a Customer_demographics.
   * @param {customer_demographicsDeleteArgs} args - Arguments to delete one Customer_demographics.
   * @example
   * // Delete one Customer_demographics
   * const Customer_demographics = await prisma.customer_demographics.delete({
   *   where: {
   *     // ... filter to delete one Customer_demographics
   *   }
   * })
   * 
  **/
  delete<T extends customer_demographicsDeleteArgs>(
    args: Subset<T, customer_demographicsDeleteArgs>
  ): CheckSelect<T, Prisma__customer_demographicsClient<customer_demographics>, Prisma__customer_demographicsClient<customer_demographicsGetPayload<T>>>
  /**
   * Update one Customer_demographics.
   * @param {customer_demographicsUpdateArgs} args - Arguments to update one Customer_demographics.
   * @example
   * // Update one Customer_demographics
   * const customer_demographics = await prisma.customer_demographics.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends customer_demographicsUpdateArgs>(
    args: Subset<T, customer_demographicsUpdateArgs>
  ): CheckSelect<T, Prisma__customer_demographicsClient<customer_demographics>, Prisma__customer_demographicsClient<customer_demographicsGetPayload<T>>>
  /**
   * Delete zero or more Customer_demographics.
   * @param {customer_demographicsDeleteManyArgs} args - Arguments to filter Customer_demographics to delete.
   * @example
   * // Delete a few Customer_demographics
   * const { count } = await prisma.customer_demographics.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends customer_demographicsDeleteManyArgs>(
    args: Subset<T, customer_demographicsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Customer_demographics.
   * @param {customer_demographicsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Customer_demographics
   * const customer_demographics = await prisma.customer_demographics.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends customer_demographicsUpdateManyArgs>(
    args: Subset<T, customer_demographicsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Customer_demographics.
   * @param {customer_demographicsUpsertArgs} args - Arguments to update or create a Customer_demographics.
   * @example
   * // Update or create a Customer_demographics
   * const customer_demographics = await prisma.customer_demographics.upsert({
   *   create: {
   *     // ... data to create a Customer_demographics
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Customer_demographics we want to update
   *   }
   * })
  **/
  upsert<T extends customer_demographicsUpsertArgs>(
    args: Subset<T, customer_demographicsUpsertArgs>
  ): CheckSelect<T, Prisma__customer_demographicsClient<customer_demographics>, Prisma__customer_demographicsClient<customer_demographicsGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManycustomer_demographicsArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for customer_demographics.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__customer_demographicsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  customer_customer_demo<T extends FindManycustomer_customer_demoArgs = {}>(args?: Subset<T, FindManycustomer_customer_demoArgs>): CheckSelect<T, Promise<Array<customer_customer_demo>>, Promise<Array<customer_customer_demoGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * customer_demographics findOne
 */
export type FindOnecustomer_demographicsArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
  /**
   * Filter, which customer_demographics to fetch.
  **/
  where: customer_demographicsWhereUniqueInput
}


/**
 * customer_demographics findMany
 */
export type FindManycustomer_demographicsArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
  /**
   * Filter, which customer_demographics to fetch.
  **/
  where?: customer_demographicsWhereInput
  /**
   * Determine the order of the customer_demographics to fetch.
  **/
  orderBy?: customer_demographicsOrderByInput
  /**
   * Sets the position for listing customer_demographics.
  **/
  cursor?: customer_demographicsWhereUniqueInput
  /**
   * The number of customer_demographics to fetch. If negative number, it will take customer_demographics before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` customer_demographics.
  **/
  skip?: number
}


/**
 * customer_demographics create
 */
export type customer_demographicsCreateArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
  /**
   * The data needed to create a customer_demographics.
  **/
  data: customer_demographicsCreateInput
}


/**
 * customer_demographics update
 */
export type customer_demographicsUpdateArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
  /**
   * The data needed to update a customer_demographics.
  **/
  data: customer_demographicsUpdateInput
  /**
   * Choose, which customer_demographics to update.
  **/
  where: customer_demographicsWhereUniqueInput
}


/**
 * customer_demographics updateMany
 */
export type customer_demographicsUpdateManyArgs = {
  data: customer_demographicsUpdateManyMutationInput
  where?: customer_demographicsWhereInput
}


/**
 * customer_demographics upsert
 */
export type customer_demographicsUpsertArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
  /**
   * The filter to search for the customer_demographics to update in case it exists.
  **/
  where: customer_demographicsWhereUniqueInput
  /**
   * In case the customer_demographics found by the `where` argument doesn't exist, create a new customer_demographics with this data.
  **/
  create: customer_demographicsCreateInput
  /**
   * In case the customer_demographics was found with the provided `where` argument, update it with this data.
  **/
  update: customer_demographicsUpdateInput
}


/**
 * customer_demographics delete
 */
export type customer_demographicsDeleteArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
  /**
   * Filter which customer_demographics to delete.
  **/
  where: customer_demographicsWhereUniqueInput
}


/**
 * customer_demographics deleteMany
 */
export type customer_demographicsDeleteManyArgs = {
  where?: customer_demographicsWhereInput
}


/**
 * customer_demographics without action
 */
export type customer_demographicsArgs = {
  /**
   * Select specific fields to fetch from the customer_demographics
  **/
  select?: customer_demographicsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customer_demographicsInclude | null
}



/**
 * Model customers
 */

export type customers = {
  address: string | null
  city: string | null
  company_name: string
  contact_name: string | null
  contact_title: string | null
  country: string | null
  customer_id: string
  fax: string | null
  phone: string | null
  postal_code: string | null
  region: string | null
}

export type customersSelect = {
  address?: boolean
  city?: boolean
  company_name?: boolean
  contact_name?: boolean
  contact_title?: boolean
  country?: boolean
  customer_id?: boolean
  fax?: boolean
  phone?: boolean
  postal_code?: boolean
  region?: boolean
  customer_customer_demo?: boolean | FindManycustomer_customer_demoArgs
  orders?: boolean | FindManyordersArgs
}

export type customersInclude = {
  customer_customer_demo?: boolean | FindManycustomer_customer_demoArgs
  orders?: boolean | FindManyordersArgs
}

export type customersGetPayload<
  S extends boolean | null | undefined | customersArgs,
  U = keyof S
> = S extends true
  ? customers
  : S extends undefined
  ? never
  : S extends customersArgs | FindManycustomersArgs
  ? 'include' extends U
    ? customers  & {
      [P in TrueKeys<S['include']>]:
      P extends 'customer_customer_demo'
      ? Array<customer_customer_demoGetPayload<S['include'][P]>> :
      P extends 'orders'
      ? Array<ordersGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof customers ? customers[P]
: 
      P extends 'customer_customer_demo'
      ? Array<customer_customer_demoGetPayload<S['select'][P]>> :
      P extends 'orders'
      ? Array<ordersGetPayload<S['select'][P]>> : never
    }
  : customers
: customers


export interface customersDelegate {
  /**
   * Find zero or one Customers.
   * @param {FindOnecustomersArgs} args - Arguments to find a Customers
   * @example
   * // Get one Customers
   * const customers = await prisma.customers.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnecustomersArgs>(
    args: Subset<T, FindOnecustomersArgs>
  ): CheckSelect<T, Prisma__customersClient<customers | null>, Prisma__customersClient<customersGetPayload<T> | null>>
  /**
   * Find zero or more Customers.
   * @param {FindManycustomersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Customers
   * const customers = await prisma.customers.findMany()
   * 
   * // Get first 10 Customers
   * const customers = await prisma.customers.findMany({ take: 10 })
   * 
   * // Only select the `address`
   * const customersWithAddressOnly = await prisma.customers.findMany({ select: { address: true } })
   * 
  **/
  findMany<T extends FindManycustomersArgs>(
    args?: Subset<T, FindManycustomersArgs>
  ): CheckSelect<T, Promise<Array<customers>>, Promise<Array<customersGetPayload<T>>>>
  /**
   * Create a Customers.
   * @param {customersCreateArgs} args - Arguments to create a Customers.
   * @example
   * // Create one Customers
   * const Customers = await prisma.customers.create({
   *   data: {
   *     // ... data to create a Customers
   *   }
   * })
   * 
  **/
  create<T extends customersCreateArgs>(
    args: Subset<T, customersCreateArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Delete a Customers.
   * @param {customersDeleteArgs} args - Arguments to delete one Customers.
   * @example
   * // Delete one Customers
   * const Customers = await prisma.customers.delete({
   *   where: {
   *     // ... filter to delete one Customers
   *   }
   * })
   * 
  **/
  delete<T extends customersDeleteArgs>(
    args: Subset<T, customersDeleteArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Update one Customers.
   * @param {customersUpdateArgs} args - Arguments to update one Customers.
   * @example
   * // Update one Customers
   * const customers = await prisma.customers.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends customersUpdateArgs>(
    args: Subset<T, customersUpdateArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Delete zero or more Customers.
   * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
   * @example
   * // Delete a few Customers
   * const { count } = await prisma.customers.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends customersDeleteManyArgs>(
    args: Subset<T, customersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Customers.
   * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Customers
   * const customers = await prisma.customers.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends customersUpdateManyArgs>(
    args: Subset<T, customersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Customers.
   * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
   * @example
   * // Update or create a Customers
   * const customers = await prisma.customers.upsert({
   *   create: {
   *     // ... data to create a Customers
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Customers we want to update
   *   }
   * })
  **/
  upsert<T extends customersUpsertArgs>(
    args: Subset<T, customersUpsertArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManycustomersArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for customers.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__customersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  customer_customer_demo<T extends FindManycustomer_customer_demoArgs = {}>(args?: Subset<T, FindManycustomer_customer_demoArgs>): CheckSelect<T, Promise<Array<customer_customer_demo>>, Promise<Array<customer_customer_demoGetPayload<T>>>>;

  orders<T extends FindManyordersArgs = {}>(args?: Subset<T, FindManyordersArgs>): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * customers findOne
 */
export type FindOnecustomersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter, which customers to fetch.
  **/
  where: customersWhereUniqueInput
}


/**
 * customers findMany
 */
export type FindManycustomersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter, which customers to fetch.
  **/
  where?: customersWhereInput
  /**
   * Determine the order of the customers to fetch.
  **/
  orderBy?: customersOrderByInput
  /**
   * Sets the position for listing customers.
  **/
  cursor?: customersWhereUniqueInput
  /**
   * The number of customers to fetch. If negative number, it will take customers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` customers.
  **/
  skip?: number
}


/**
 * customers create
 */
export type customersCreateArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * The data needed to create a customers.
  **/
  data: customersCreateInput
}


/**
 * customers update
 */
export type customersUpdateArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * The data needed to update a customers.
  **/
  data: customersUpdateInput
  /**
   * Choose, which customers to update.
  **/
  where: customersWhereUniqueInput
}


/**
 * customers updateMany
 */
export type customersUpdateManyArgs = {
  data: customersUpdateManyMutationInput
  where?: customersWhereInput
}


/**
 * customers upsert
 */
export type customersUpsertArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * The filter to search for the customers to update in case it exists.
  **/
  where: customersWhereUniqueInput
  /**
   * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
  **/
  create: customersCreateInput
  /**
   * In case the customers was found with the provided `where` argument, update it with this data.
  **/
  update: customersUpdateInput
}


/**
 * customers delete
 */
export type customersDeleteArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter which customers to delete.
  **/
  where: customersWhereUniqueInput
}


/**
 * customers deleteMany
 */
export type customersDeleteManyArgs = {
  where?: customersWhereInput
}


/**
 * customers without action
 */
export type customersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
}



/**
 * Model employee_territories
 */

export type employee_territories = {
  employee_id: number
  territory_id: string
}

export type employee_territoriesSelect = {
  employee_id?: boolean
  territory_id?: boolean
  employees?: boolean | employeesArgs
  territories?: boolean | territoriesArgs
}

export type employee_territoriesInclude = {
  employees?: boolean | employeesArgs
  territories?: boolean | territoriesArgs
}

export type employee_territoriesGetPayload<
  S extends boolean | null | undefined | employee_territoriesArgs,
  U = keyof S
> = S extends true
  ? employee_territories
  : S extends undefined
  ? never
  : S extends employee_territoriesArgs | FindManyemployee_territoriesArgs
  ? 'include' extends U
    ? employee_territories  & {
      [P in TrueKeys<S['include']>]:
      P extends 'employees'
      ? employeesGetPayload<S['include'][P]> :
      P extends 'territories'
      ? territoriesGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof employee_territories ? employee_territories[P]
: 
      P extends 'employees'
      ? employeesGetPayload<S['select'][P]> :
      P extends 'territories'
      ? territoriesGetPayload<S['select'][P]> : never
    }
  : employee_territories
: employee_territories


export interface employee_territoriesDelegate {
  /**
   * Find zero or one Employee_territories.
   * @param {FindOneemployee_territoriesArgs} args - Arguments to find a Employee_territories
   * @example
   * // Get one Employee_territories
   * const employee_territories = await prisma.employee_territories.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneemployee_territoriesArgs>(
    args: Subset<T, FindOneemployee_territoriesArgs>
  ): CheckSelect<T, Prisma__employee_territoriesClient<employee_territories | null>, Prisma__employee_territoriesClient<employee_territoriesGetPayload<T> | null>>
  /**
   * Find zero or more Employee_territories.
   * @param {FindManyemployee_territoriesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Employee_territories
   * const employee_territories = await prisma.employee_territories.findMany()
   * 
   * // Get first 10 Employee_territories
   * const employee_territories = await prisma.employee_territories.findMany({ take: 10 })
   * 
   * // Only select the `employee_id`
   * const employee_territoriesWithEmployee_idOnly = await prisma.employee_territories.findMany({ select: { employee_id: true } })
   * 
  **/
  findMany<T extends FindManyemployee_territoriesArgs>(
    args?: Subset<T, FindManyemployee_territoriesArgs>
  ): CheckSelect<T, Promise<Array<employee_territories>>, Promise<Array<employee_territoriesGetPayload<T>>>>
  /**
   * Create a Employee_territories.
   * @param {employee_territoriesCreateArgs} args - Arguments to create a Employee_territories.
   * @example
   * // Create one Employee_territories
   * const Employee_territories = await prisma.employee_territories.create({
   *   data: {
   *     // ... data to create a Employee_territories
   *   }
   * })
   * 
  **/
  create<T extends employee_territoriesCreateArgs>(
    args: Subset<T, employee_territoriesCreateArgs>
  ): CheckSelect<T, Prisma__employee_territoriesClient<employee_territories>, Prisma__employee_territoriesClient<employee_territoriesGetPayload<T>>>
  /**
   * Delete a Employee_territories.
   * @param {employee_territoriesDeleteArgs} args - Arguments to delete one Employee_territories.
   * @example
   * // Delete one Employee_territories
   * const Employee_territories = await prisma.employee_territories.delete({
   *   where: {
   *     // ... filter to delete one Employee_territories
   *   }
   * })
   * 
  **/
  delete<T extends employee_territoriesDeleteArgs>(
    args: Subset<T, employee_territoriesDeleteArgs>
  ): CheckSelect<T, Prisma__employee_territoriesClient<employee_territories>, Prisma__employee_territoriesClient<employee_territoriesGetPayload<T>>>
  /**
   * Update one Employee_territories.
   * @param {employee_territoriesUpdateArgs} args - Arguments to update one Employee_territories.
   * @example
   * // Update one Employee_territories
   * const employee_territories = await prisma.employee_territories.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends employee_territoriesUpdateArgs>(
    args: Subset<T, employee_territoriesUpdateArgs>
  ): CheckSelect<T, Prisma__employee_territoriesClient<employee_territories>, Prisma__employee_territoriesClient<employee_territoriesGetPayload<T>>>
  /**
   * Delete zero or more Employee_territories.
   * @param {employee_territoriesDeleteManyArgs} args - Arguments to filter Employee_territories to delete.
   * @example
   * // Delete a few Employee_territories
   * const { count } = await prisma.employee_territories.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends employee_territoriesDeleteManyArgs>(
    args: Subset<T, employee_territoriesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Employee_territories.
   * @param {employee_territoriesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Employee_territories
   * const employee_territories = await prisma.employee_territories.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends employee_territoriesUpdateManyArgs>(
    args: Subset<T, employee_territoriesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Employee_territories.
   * @param {employee_territoriesUpsertArgs} args - Arguments to update or create a Employee_territories.
   * @example
   * // Update or create a Employee_territories
   * const employee_territories = await prisma.employee_territories.upsert({
   *   create: {
   *     // ... data to create a Employee_territories
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Employee_territories we want to update
   *   }
   * })
  **/
  upsert<T extends employee_territoriesUpsertArgs>(
    args: Subset<T, employee_territoriesUpsertArgs>
  ): CheckSelect<T, Prisma__employee_territoriesClient<employee_territories>, Prisma__employee_territoriesClient<employee_territoriesGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyemployee_territoriesArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for employee_territories.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__employee_territoriesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  employees<T extends employeesArgs = {}>(args?: Subset<T, employeesArgs>): CheckSelect<T, Prisma__employeesClient<employees | null>, Prisma__employeesClient<employeesGetPayload<T> | null>>;

  territories<T extends territoriesArgs = {}>(args?: Subset<T, territoriesArgs>): CheckSelect<T, Prisma__territoriesClient<territories | null>, Prisma__territoriesClient<territoriesGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * employee_territories findOne
 */
export type FindOneemployee_territoriesArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
  /**
   * Filter, which employee_territories to fetch.
  **/
  where: employee_territoriesWhereUniqueInput
}


/**
 * employee_territories findMany
 */
export type FindManyemployee_territoriesArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
  /**
   * Filter, which employee_territories to fetch.
  **/
  where?: employee_territoriesWhereInput
  /**
   * Determine the order of the employee_territories to fetch.
  **/
  orderBy?: employee_territoriesOrderByInput
  /**
   * Sets the position for listing employee_territories.
  **/
  cursor?: employee_territoriesWhereUniqueInput
  /**
   * The number of employee_territories to fetch. If negative number, it will take employee_territories before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` employee_territories.
  **/
  skip?: number
}


/**
 * employee_territories create
 */
export type employee_territoriesCreateArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
  /**
   * The data needed to create a employee_territories.
  **/
  data: employee_territoriesCreateInput
}


/**
 * employee_territories update
 */
export type employee_territoriesUpdateArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
  /**
   * The data needed to update a employee_territories.
  **/
  data: employee_territoriesUpdateInput
  /**
   * Choose, which employee_territories to update.
  **/
  where: employee_territoriesWhereUniqueInput
}


/**
 * employee_territories updateMany
 */
export type employee_territoriesUpdateManyArgs = {
  data: employee_territoriesUpdateManyMutationInput
  where?: employee_territoriesWhereInput
}


/**
 * employee_territories upsert
 */
export type employee_territoriesUpsertArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
  /**
   * The filter to search for the employee_territories to update in case it exists.
  **/
  where: employee_territoriesWhereUniqueInput
  /**
   * In case the employee_territories found by the `where` argument doesn't exist, create a new employee_territories with this data.
  **/
  create: employee_territoriesCreateInput
  /**
   * In case the employee_territories was found with the provided `where` argument, update it with this data.
  **/
  update: employee_territoriesUpdateInput
}


/**
 * employee_territories delete
 */
export type employee_territoriesDeleteArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
  /**
   * Filter which employee_territories to delete.
  **/
  where: employee_territoriesWhereUniqueInput
}


/**
 * employee_territories deleteMany
 */
export type employee_territoriesDeleteManyArgs = {
  where?: employee_territoriesWhereInput
}


/**
 * employee_territories without action
 */
export type employee_territoriesArgs = {
  /**
   * Select specific fields to fetch from the employee_territories
  **/
  select?: employee_territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employee_territoriesInclude | null
}



/**
 * Model employees
 */

export type employees = {
  address: string | null
  birth_date: Date | null
  city: string | null
  country: string | null
  employee_id: number
  extension: string | null
  first_name: string
  hire_date: Date | null
  home_phone: string | null
  last_name: string
  notes: string | null
  photo_path: string | null
  postal_code: string | null
  region: string | null
  reports_to: number | null
  title: string | null
  title_of_courtesy: string | null
}

export type employeesSelect = {
  address?: boolean
  birth_date?: boolean
  city?: boolean
  country?: boolean
  employee_id?: boolean
  extension?: boolean
  first_name?: boolean
  hire_date?: boolean
  home_phone?: boolean
  last_name?: boolean
  notes?: boolean
  photo_path?: boolean
  postal_code?: boolean
  region?: boolean
  reports_to?: boolean
  title?: boolean
  title_of_courtesy?: boolean
  employees?: boolean | employeesArgs
  employee_territories?: boolean | FindManyemployee_territoriesArgs
  other_employees?: boolean | FindManyemployeesArgs
  orders?: boolean | FindManyordersArgs
}

export type employeesInclude = {
  employees?: boolean | employeesArgs
  employee_territories?: boolean | FindManyemployee_territoriesArgs
  other_employees?: boolean | FindManyemployeesArgs
  orders?: boolean | FindManyordersArgs
}

export type employeesGetPayload<
  S extends boolean | null | undefined | employeesArgs,
  U = keyof S
> = S extends true
  ? employees
  : S extends undefined
  ? never
  : S extends employeesArgs | FindManyemployeesArgs
  ? 'include' extends U
    ? employees  & {
      [P in TrueKeys<S['include']>]:
      P extends 'employees'
      ? employeesGetPayload<S['include'][P]> | null :
      P extends 'employee_territories'
      ? Array<employee_territoriesGetPayload<S['include'][P]>> :
      P extends 'other_employees'
      ? Array<employeesGetPayload<S['include'][P]>> :
      P extends 'orders'
      ? Array<ordersGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof employees ? employees[P]
: 
      P extends 'employees'
      ? employeesGetPayload<S['select'][P]> | null :
      P extends 'employee_territories'
      ? Array<employee_territoriesGetPayload<S['select'][P]>> :
      P extends 'other_employees'
      ? Array<employeesGetPayload<S['select'][P]>> :
      P extends 'orders'
      ? Array<ordersGetPayload<S['select'][P]>> : never
    }
  : employees
: employees


export interface employeesDelegate {
  /**
   * Find zero or one Employees.
   * @param {FindOneemployeesArgs} args - Arguments to find a Employees
   * @example
   * // Get one Employees
   * const employees = await prisma.employees.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneemployeesArgs>(
    args: Subset<T, FindOneemployeesArgs>
  ): CheckSelect<T, Prisma__employeesClient<employees | null>, Prisma__employeesClient<employeesGetPayload<T> | null>>
  /**
   * Find zero or more Employees.
   * @param {FindManyemployeesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Employees
   * const employees = await prisma.employees.findMany()
   * 
   * // Get first 10 Employees
   * const employees = await prisma.employees.findMany({ take: 10 })
   * 
   * // Only select the `address`
   * const employeesWithAddressOnly = await prisma.employees.findMany({ select: { address: true } })
   * 
  **/
  findMany<T extends FindManyemployeesArgs>(
    args?: Subset<T, FindManyemployeesArgs>
  ): CheckSelect<T, Promise<Array<employees>>, Promise<Array<employeesGetPayload<T>>>>
  /**
   * Create a Employees.
   * @param {employeesCreateArgs} args - Arguments to create a Employees.
   * @example
   * // Create one Employees
   * const Employees = await prisma.employees.create({
   *   data: {
   *     // ... data to create a Employees
   *   }
   * })
   * 
  **/
  create<T extends employeesCreateArgs>(
    args: Subset<T, employeesCreateArgs>
  ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>
  /**
   * Delete a Employees.
   * @param {employeesDeleteArgs} args - Arguments to delete one Employees.
   * @example
   * // Delete one Employees
   * const Employees = await prisma.employees.delete({
   *   where: {
   *     // ... filter to delete one Employees
   *   }
   * })
   * 
  **/
  delete<T extends employeesDeleteArgs>(
    args: Subset<T, employeesDeleteArgs>
  ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>
  /**
   * Update one Employees.
   * @param {employeesUpdateArgs} args - Arguments to update one Employees.
   * @example
   * // Update one Employees
   * const employees = await prisma.employees.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends employeesUpdateArgs>(
    args: Subset<T, employeesUpdateArgs>
  ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>
  /**
   * Delete zero or more Employees.
   * @param {employeesDeleteManyArgs} args - Arguments to filter Employees to delete.
   * @example
   * // Delete a few Employees
   * const { count } = await prisma.employees.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends employeesDeleteManyArgs>(
    args: Subset<T, employeesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Employees.
   * @param {employeesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Employees
   * const employees = await prisma.employees.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends employeesUpdateManyArgs>(
    args: Subset<T, employeesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Employees.
   * @param {employeesUpsertArgs} args - Arguments to update or create a Employees.
   * @example
   * // Update or create a Employees
   * const employees = await prisma.employees.upsert({
   *   create: {
   *     // ... data to create a Employees
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Employees we want to update
   *   }
   * })
  **/
  upsert<T extends employeesUpsertArgs>(
    args: Subset<T, employeesUpsertArgs>
  ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyemployeesArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for employees.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__employeesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  employees<T extends employeesArgs = {}>(args?: Subset<T, employeesArgs>): CheckSelect<T, Prisma__employeesClient<employees | null>, Prisma__employeesClient<employeesGetPayload<T> | null>>;

  employee_territories<T extends FindManyemployee_territoriesArgs = {}>(args?: Subset<T, FindManyemployee_territoriesArgs>): CheckSelect<T, Promise<Array<employee_territories>>, Promise<Array<employee_territoriesGetPayload<T>>>>;

  other_employees<T extends FindManyemployeesArgs = {}>(args?: Subset<T, FindManyemployeesArgs>): CheckSelect<T, Promise<Array<employees>>, Promise<Array<employeesGetPayload<T>>>>;

  orders<T extends FindManyordersArgs = {}>(args?: Subset<T, FindManyordersArgs>): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * employees findOne
 */
export type FindOneemployeesArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
  /**
   * Filter, which employees to fetch.
  **/
  where: employeesWhereUniqueInput
}


/**
 * employees findMany
 */
export type FindManyemployeesArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
  /**
   * Filter, which employees to fetch.
  **/
  where?: employeesWhereInput
  /**
   * Determine the order of the employees to fetch.
  **/
  orderBy?: employeesOrderByInput
  /**
   * Sets the position for listing employees.
  **/
  cursor?: employeesWhereUniqueInput
  /**
   * The number of employees to fetch. If negative number, it will take employees before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` employees.
  **/
  skip?: number
}


/**
 * employees create
 */
export type employeesCreateArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
  /**
   * The data needed to create a employees.
  **/
  data: employeesCreateInput
}


/**
 * employees update
 */
export type employeesUpdateArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
  /**
   * The data needed to update a employees.
  **/
  data: employeesUpdateInput
  /**
   * Choose, which employees to update.
  **/
  where: employeesWhereUniqueInput
}


/**
 * employees updateMany
 */
export type employeesUpdateManyArgs = {
  data: employeesUpdateManyMutationInput
  where?: employeesWhereInput
}


/**
 * employees upsert
 */
export type employeesUpsertArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
  /**
   * The filter to search for the employees to update in case it exists.
  **/
  where: employeesWhereUniqueInput
  /**
   * In case the employees found by the `where` argument doesn't exist, create a new employees with this data.
  **/
  create: employeesCreateInput
  /**
   * In case the employees was found with the provided `where` argument, update it with this data.
  **/
  update: employeesUpdateInput
}


/**
 * employees delete
 */
export type employeesDeleteArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
  /**
   * Filter which employees to delete.
  **/
  where: employeesWhereUniqueInput
}


/**
 * employees deleteMany
 */
export type employeesDeleteManyArgs = {
  where?: employeesWhereInput
}


/**
 * employees without action
 */
export type employeesArgs = {
  /**
   * Select specific fields to fetch from the employees
  **/
  select?: employeesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: employeesInclude | null
}



/**
 * Model order_details
 */

export type order_details = {
  discount: number
  order_id: number
  product_id: number
  quantity: number
  unit_price: number
}

export type order_detailsSelect = {
  discount?: boolean
  order_id?: boolean
  product_id?: boolean
  quantity?: boolean
  unit_price?: boolean
  orders?: boolean | ordersArgs
  products?: boolean | productsArgs
}

export type order_detailsInclude = {
  orders?: boolean | ordersArgs
  products?: boolean | productsArgs
}

export type order_detailsGetPayload<
  S extends boolean | null | undefined | order_detailsArgs,
  U = keyof S
> = S extends true
  ? order_details
  : S extends undefined
  ? never
  : S extends order_detailsArgs | FindManyorder_detailsArgs
  ? 'include' extends U
    ? order_details  & {
      [P in TrueKeys<S['include']>]:
      P extends 'orders'
      ? ordersGetPayload<S['include'][P]> :
      P extends 'products'
      ? productsGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof order_details ? order_details[P]
: 
      P extends 'orders'
      ? ordersGetPayload<S['select'][P]> :
      P extends 'products'
      ? productsGetPayload<S['select'][P]> : never
    }
  : order_details
: order_details


export interface order_detailsDelegate {
  /**
   * Find zero or one Order_details.
   * @param {FindOneorder_detailsArgs} args - Arguments to find a Order_details
   * @example
   * // Get one Order_details
   * const order_details = await prisma.order_details.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneorder_detailsArgs>(
    args: Subset<T, FindOneorder_detailsArgs>
  ): CheckSelect<T, Prisma__order_detailsClient<order_details | null>, Prisma__order_detailsClient<order_detailsGetPayload<T> | null>>
  /**
   * Find zero or more Order_details.
   * @param {FindManyorder_detailsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Order_details
   * const order_details = await prisma.order_details.findMany()
   * 
   * // Get first 10 Order_details
   * const order_details = await prisma.order_details.findMany({ take: 10 })
   * 
   * // Only select the `discount`
   * const order_detailsWithDiscountOnly = await prisma.order_details.findMany({ select: { discount: true } })
   * 
  **/
  findMany<T extends FindManyorder_detailsArgs>(
    args?: Subset<T, FindManyorder_detailsArgs>
  ): CheckSelect<T, Promise<Array<order_details>>, Promise<Array<order_detailsGetPayload<T>>>>
  /**
   * Create a Order_details.
   * @param {order_detailsCreateArgs} args - Arguments to create a Order_details.
   * @example
   * // Create one Order_details
   * const Order_details = await prisma.order_details.create({
   *   data: {
   *     // ... data to create a Order_details
   *   }
   * })
   * 
  **/
  create<T extends order_detailsCreateArgs>(
    args: Subset<T, order_detailsCreateArgs>
  ): CheckSelect<T, Prisma__order_detailsClient<order_details>, Prisma__order_detailsClient<order_detailsGetPayload<T>>>
  /**
   * Delete a Order_details.
   * @param {order_detailsDeleteArgs} args - Arguments to delete one Order_details.
   * @example
   * // Delete one Order_details
   * const Order_details = await prisma.order_details.delete({
   *   where: {
   *     // ... filter to delete one Order_details
   *   }
   * })
   * 
  **/
  delete<T extends order_detailsDeleteArgs>(
    args: Subset<T, order_detailsDeleteArgs>
  ): CheckSelect<T, Prisma__order_detailsClient<order_details>, Prisma__order_detailsClient<order_detailsGetPayload<T>>>
  /**
   * Update one Order_details.
   * @param {order_detailsUpdateArgs} args - Arguments to update one Order_details.
   * @example
   * // Update one Order_details
   * const order_details = await prisma.order_details.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends order_detailsUpdateArgs>(
    args: Subset<T, order_detailsUpdateArgs>
  ): CheckSelect<T, Prisma__order_detailsClient<order_details>, Prisma__order_detailsClient<order_detailsGetPayload<T>>>
  /**
   * Delete zero or more Order_details.
   * @param {order_detailsDeleteManyArgs} args - Arguments to filter Order_details to delete.
   * @example
   * // Delete a few Order_details
   * const { count } = await prisma.order_details.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends order_detailsDeleteManyArgs>(
    args: Subset<T, order_detailsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Order_details.
   * @param {order_detailsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Order_details
   * const order_details = await prisma.order_details.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends order_detailsUpdateManyArgs>(
    args: Subset<T, order_detailsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Order_details.
   * @param {order_detailsUpsertArgs} args - Arguments to update or create a Order_details.
   * @example
   * // Update or create a Order_details
   * const order_details = await prisma.order_details.upsert({
   *   create: {
   *     // ... data to create a Order_details
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Order_details we want to update
   *   }
   * })
  **/
  upsert<T extends order_detailsUpsertArgs>(
    args: Subset<T, order_detailsUpsertArgs>
  ): CheckSelect<T, Prisma__order_detailsClient<order_details>, Prisma__order_detailsClient<order_detailsGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyorder_detailsArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for order_details.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__order_detailsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  orders<T extends ordersArgs = {}>(args?: Subset<T, ordersArgs>): CheckSelect<T, Prisma__ordersClient<orders | null>, Prisma__ordersClient<ordersGetPayload<T> | null>>;

  products<T extends productsArgs = {}>(args?: Subset<T, productsArgs>): CheckSelect<T, Prisma__productsClient<products | null>, Prisma__productsClient<productsGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * order_details findOne
 */
export type FindOneorder_detailsArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
  /**
   * Filter, which order_details to fetch.
  **/
  where: order_detailsWhereUniqueInput
}


/**
 * order_details findMany
 */
export type FindManyorder_detailsArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
  /**
   * Filter, which order_details to fetch.
  **/
  where?: order_detailsWhereInput
  /**
   * Determine the order of the order_details to fetch.
  **/
  orderBy?: order_detailsOrderByInput
  /**
   * Sets the position for listing order_details.
  **/
  cursor?: order_detailsWhereUniqueInput
  /**
   * The number of order_details to fetch. If negative number, it will take order_details before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` order_details.
  **/
  skip?: number
}


/**
 * order_details create
 */
export type order_detailsCreateArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
  /**
   * The data needed to create a order_details.
  **/
  data: order_detailsCreateInput
}


/**
 * order_details update
 */
export type order_detailsUpdateArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
  /**
   * The data needed to update a order_details.
  **/
  data: order_detailsUpdateInput
  /**
   * Choose, which order_details to update.
  **/
  where: order_detailsWhereUniqueInput
}


/**
 * order_details updateMany
 */
export type order_detailsUpdateManyArgs = {
  data: order_detailsUpdateManyMutationInput
  where?: order_detailsWhereInput
}


/**
 * order_details upsert
 */
export type order_detailsUpsertArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
  /**
   * The filter to search for the order_details to update in case it exists.
  **/
  where: order_detailsWhereUniqueInput
  /**
   * In case the order_details found by the `where` argument doesn't exist, create a new order_details with this data.
  **/
  create: order_detailsCreateInput
  /**
   * In case the order_details was found with the provided `where` argument, update it with this data.
  **/
  update: order_detailsUpdateInput
}


/**
 * order_details delete
 */
export type order_detailsDeleteArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
  /**
   * Filter which order_details to delete.
  **/
  where: order_detailsWhereUniqueInput
}


/**
 * order_details deleteMany
 */
export type order_detailsDeleteManyArgs = {
  where?: order_detailsWhereInput
}


/**
 * order_details without action
 */
export type order_detailsArgs = {
  /**
   * Select specific fields to fetch from the order_details
  **/
  select?: order_detailsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: order_detailsInclude | null
}



/**
 * Model orders
 */

export type orders = {
  customer_id: string | null
  employee_id: number | null
  freight: number | null
  order_date: Date | null
  order_id: number
  required_date: Date | null
  ship_address: string | null
  ship_city: string | null
  ship_country: string | null
  ship_name: string | null
  ship_postal_code: string | null
  ship_region: string | null
  ship_via: number | null
  shipped_date: Date | null
}

export type ordersSelect = {
  customer_id?: boolean
  employee_id?: boolean
  freight?: boolean
  order_date?: boolean
  order_id?: boolean
  required_date?: boolean
  ship_address?: boolean
  ship_city?: boolean
  ship_country?: boolean
  ship_name?: boolean
  ship_postal_code?: boolean
  ship_region?: boolean
  ship_via?: boolean
  shipped_date?: boolean
  customers?: boolean | customersArgs
  employees?: boolean | employeesArgs
  shippers?: boolean | shippersArgs
  order_details?: boolean | FindManyorder_detailsArgs
}

export type ordersInclude = {
  customers?: boolean | customersArgs
  employees?: boolean | employeesArgs
  shippers?: boolean | shippersArgs
  order_details?: boolean | FindManyorder_detailsArgs
}

export type ordersGetPayload<
  S extends boolean | null | undefined | ordersArgs,
  U = keyof S
> = S extends true
  ? orders
  : S extends undefined
  ? never
  : S extends ordersArgs | FindManyordersArgs
  ? 'include' extends U
    ? orders  & {
      [P in TrueKeys<S['include']>]:
      P extends 'customers'
      ? customersGetPayload<S['include'][P]> | null :
      P extends 'employees'
      ? employeesGetPayload<S['include'][P]> | null :
      P extends 'shippers'
      ? shippersGetPayload<S['include'][P]> | null :
      P extends 'order_details'
      ? Array<order_detailsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof orders ? orders[P]
: 
      P extends 'customers'
      ? customersGetPayload<S['select'][P]> | null :
      P extends 'employees'
      ? employeesGetPayload<S['select'][P]> | null :
      P extends 'shippers'
      ? shippersGetPayload<S['select'][P]> | null :
      P extends 'order_details'
      ? Array<order_detailsGetPayload<S['select'][P]>> : never
    }
  : orders
: orders


export interface ordersDelegate {
  /**
   * Find zero or one Orders.
   * @param {FindOneordersArgs} args - Arguments to find a Orders
   * @example
   * // Get one Orders
   * const orders = await prisma.orders.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneordersArgs>(
    args: Subset<T, FindOneordersArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders | null>, Prisma__ordersClient<ordersGetPayload<T> | null>>
  /**
   * Find zero or more Orders.
   * @param {FindManyordersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Orders
   * const orders = await prisma.orders.findMany()
   * 
   * // Get first 10 Orders
   * const orders = await prisma.orders.findMany({ take: 10 })
   * 
   * // Only select the `customer_id`
   * const ordersWithCustomer_idOnly = await prisma.orders.findMany({ select: { customer_id: true } })
   * 
  **/
  findMany<T extends FindManyordersArgs>(
    args?: Subset<T, FindManyordersArgs>
  ): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>
  /**
   * Create a Orders.
   * @param {ordersCreateArgs} args - Arguments to create a Orders.
   * @example
   * // Create one Orders
   * const Orders = await prisma.orders.create({
   *   data: {
   *     // ... data to create a Orders
   *   }
   * })
   * 
  **/
  create<T extends ordersCreateArgs>(
    args: Subset<T, ordersCreateArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Delete a Orders.
   * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
   * @example
   * // Delete one Orders
   * const Orders = await prisma.orders.delete({
   *   where: {
   *     // ... filter to delete one Orders
   *   }
   * })
   * 
  **/
  delete<T extends ordersDeleteArgs>(
    args: Subset<T, ordersDeleteArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Update one Orders.
   * @param {ordersUpdateArgs} args - Arguments to update one Orders.
   * @example
   * // Update one Orders
   * const orders = await prisma.orders.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ordersUpdateArgs>(
    args: Subset<T, ordersUpdateArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Delete zero or more Orders.
   * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
   * @example
   * // Delete a few Orders
   * const { count } = await prisma.orders.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ordersDeleteManyArgs>(
    args: Subset<T, ordersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Orders.
   * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Orders
   * const orders = await prisma.orders.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ordersUpdateManyArgs>(
    args: Subset<T, ordersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Orders.
   * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
   * @example
   * // Update or create a Orders
   * const orders = await prisma.orders.upsert({
   *   create: {
   *     // ... data to create a Orders
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Orders we want to update
   *   }
   * })
  **/
  upsert<T extends ordersUpsertArgs>(
    args: Subset<T, ordersUpsertArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyordersArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for orders.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ordersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  customers<T extends customersArgs = {}>(args?: Subset<T, customersArgs>): CheckSelect<T, Prisma__customersClient<customers | null>, Prisma__customersClient<customersGetPayload<T> | null>>;

  employees<T extends employeesArgs = {}>(args?: Subset<T, employeesArgs>): CheckSelect<T, Prisma__employeesClient<employees | null>, Prisma__employeesClient<employeesGetPayload<T> | null>>;

  shippers<T extends shippersArgs = {}>(args?: Subset<T, shippersArgs>): CheckSelect<T, Prisma__shippersClient<shippers | null>, Prisma__shippersClient<shippersGetPayload<T> | null>>;

  order_details<T extends FindManyorder_detailsArgs = {}>(args?: Subset<T, FindManyorder_detailsArgs>): CheckSelect<T, Promise<Array<order_details>>, Promise<Array<order_detailsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * orders findOne
 */
export type FindOneordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter, which orders to fetch.
  **/
  where: ordersWhereUniqueInput
}


/**
 * orders findMany
 */
export type FindManyordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter, which orders to fetch.
  **/
  where?: ordersWhereInput
  /**
   * Determine the order of the orders to fetch.
  **/
  orderBy?: ordersOrderByInput
  /**
   * Sets the position for listing orders.
  **/
  cursor?: ordersWhereUniqueInput
  /**
   * The number of orders to fetch. If negative number, it will take orders before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` orders.
  **/
  skip?: number
}


/**
 * orders create
 */
export type ordersCreateArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * The data needed to create a orders.
  **/
  data: ordersCreateInput
}


/**
 * orders update
 */
export type ordersUpdateArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * The data needed to update a orders.
  **/
  data: ordersUpdateInput
  /**
   * Choose, which orders to update.
  **/
  where: ordersWhereUniqueInput
}


/**
 * orders updateMany
 */
export type ordersUpdateManyArgs = {
  data: ordersUpdateManyMutationInput
  where?: ordersWhereInput
}


/**
 * orders upsert
 */
export type ordersUpsertArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * The filter to search for the orders to update in case it exists.
  **/
  where: ordersWhereUniqueInput
  /**
   * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
  **/
  create: ordersCreateInput
  /**
   * In case the orders was found with the provided `where` argument, update it with this data.
  **/
  update: ordersUpdateInput
}


/**
 * orders delete
 */
export type ordersDeleteArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter which orders to delete.
  **/
  where: ordersWhereUniqueInput
}


/**
 * orders deleteMany
 */
export type ordersDeleteManyArgs = {
  where?: ordersWhereInput
}


/**
 * orders without action
 */
export type ordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
}



/**
 * Model products
 */

export type products = {
  category_id: number | null
  discontinued: number
  product_id: number
  product_name: string
  quantity_per_unit: string | null
  reorder_level: number | null
  supplier_id: number | null
  unit_price: number | null
  units_in_stock: number | null
  units_on_order: number | null
}

export type productsSelect = {
  category_id?: boolean
  discontinued?: boolean
  product_id?: boolean
  product_name?: boolean
  quantity_per_unit?: boolean
  reorder_level?: boolean
  supplier_id?: boolean
  unit_price?: boolean
  units_in_stock?: boolean
  units_on_order?: boolean
  categories?: boolean | categoriesArgs
  suppliers?: boolean | suppliersArgs
  order_details?: boolean | FindManyorder_detailsArgs
}

export type productsInclude = {
  categories?: boolean | categoriesArgs
  suppliers?: boolean | suppliersArgs
  order_details?: boolean | FindManyorder_detailsArgs
}

export type productsGetPayload<
  S extends boolean | null | undefined | productsArgs,
  U = keyof S
> = S extends true
  ? products
  : S extends undefined
  ? never
  : S extends productsArgs | FindManyproductsArgs
  ? 'include' extends U
    ? products  & {
      [P in TrueKeys<S['include']>]:
      P extends 'categories'
      ? categoriesGetPayload<S['include'][P]> | null :
      P extends 'suppliers'
      ? suppliersGetPayload<S['include'][P]> | null :
      P extends 'order_details'
      ? Array<order_detailsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof products ? products[P]
: 
      P extends 'categories'
      ? categoriesGetPayload<S['select'][P]> | null :
      P extends 'suppliers'
      ? suppliersGetPayload<S['select'][P]> | null :
      P extends 'order_details'
      ? Array<order_detailsGetPayload<S['select'][P]>> : never
    }
  : products
: products


export interface productsDelegate {
  /**
   * Find zero or one Products.
   * @param {FindOneproductsArgs} args - Arguments to find a Products
   * @example
   * // Get one Products
   * const products = await prisma.products.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneproductsArgs>(
    args: Subset<T, FindOneproductsArgs>
  ): CheckSelect<T, Prisma__productsClient<products | null>, Prisma__productsClient<productsGetPayload<T> | null>>
  /**
   * Find zero or more Products.
   * @param {FindManyproductsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Products
   * const products = await prisma.products.findMany()
   * 
   * // Get first 10 Products
   * const products = await prisma.products.findMany({ take: 10 })
   * 
   * // Only select the `category_id`
   * const productsWithCategory_idOnly = await prisma.products.findMany({ select: { category_id: true } })
   * 
  **/
  findMany<T extends FindManyproductsArgs>(
    args?: Subset<T, FindManyproductsArgs>
  ): CheckSelect<T, Promise<Array<products>>, Promise<Array<productsGetPayload<T>>>>
  /**
   * Create a Products.
   * @param {productsCreateArgs} args - Arguments to create a Products.
   * @example
   * // Create one Products
   * const Products = await prisma.products.create({
   *   data: {
   *     // ... data to create a Products
   *   }
   * })
   * 
  **/
  create<T extends productsCreateArgs>(
    args: Subset<T, productsCreateArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Delete a Products.
   * @param {productsDeleteArgs} args - Arguments to delete one Products.
   * @example
   * // Delete one Products
   * const Products = await prisma.products.delete({
   *   where: {
   *     // ... filter to delete one Products
   *   }
   * })
   * 
  **/
  delete<T extends productsDeleteArgs>(
    args: Subset<T, productsDeleteArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Update one Products.
   * @param {productsUpdateArgs} args - Arguments to update one Products.
   * @example
   * // Update one Products
   * const products = await prisma.products.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends productsUpdateArgs>(
    args: Subset<T, productsUpdateArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Delete zero or more Products.
   * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
   * @example
   * // Delete a few Products
   * const { count } = await prisma.products.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends productsDeleteManyArgs>(
    args: Subset<T, productsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Products.
   * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Products
   * const products = await prisma.products.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends productsUpdateManyArgs>(
    args: Subset<T, productsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Products.
   * @param {productsUpsertArgs} args - Arguments to update or create a Products.
   * @example
   * // Update or create a Products
   * const products = await prisma.products.upsert({
   *   create: {
   *     // ... data to create a Products
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Products we want to update
   *   }
   * })
  **/
  upsert<T extends productsUpsertArgs>(
    args: Subset<T, productsUpsertArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyproductsArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for products.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__productsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  categories<T extends categoriesArgs = {}>(args?: Subset<T, categoriesArgs>): CheckSelect<T, Prisma__categoriesClient<categories | null>, Prisma__categoriesClient<categoriesGetPayload<T> | null>>;

  suppliers<T extends suppliersArgs = {}>(args?: Subset<T, suppliersArgs>): CheckSelect<T, Prisma__suppliersClient<suppliers | null>, Prisma__suppliersClient<suppliersGetPayload<T> | null>>;

  order_details<T extends FindManyorder_detailsArgs = {}>(args?: Subset<T, FindManyorder_detailsArgs>): CheckSelect<T, Promise<Array<order_details>>, Promise<Array<order_detailsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * products findOne
 */
export type FindOneproductsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter, which products to fetch.
  **/
  where: productsWhereUniqueInput
}


/**
 * products findMany
 */
export type FindManyproductsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter, which products to fetch.
  **/
  where?: productsWhereInput
  /**
   * Determine the order of the products to fetch.
  **/
  orderBy?: productsOrderByInput
  /**
   * Sets the position for listing products.
  **/
  cursor?: productsWhereUniqueInput
  /**
   * The number of products to fetch. If negative number, it will take products before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` products.
  **/
  skip?: number
}


/**
 * products create
 */
export type productsCreateArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * The data needed to create a products.
  **/
  data: productsCreateInput
}


/**
 * products update
 */
export type productsUpdateArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * The data needed to update a products.
  **/
  data: productsUpdateInput
  /**
   * Choose, which products to update.
  **/
  where: productsWhereUniqueInput
}


/**
 * products updateMany
 */
export type productsUpdateManyArgs = {
  data: productsUpdateManyMutationInput
  where?: productsWhereInput
}


/**
 * products upsert
 */
export type productsUpsertArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * The filter to search for the products to update in case it exists.
  **/
  where: productsWhereUniqueInput
  /**
   * In case the products found by the `where` argument doesn't exist, create a new products with this data.
  **/
  create: productsCreateInput
  /**
   * In case the products was found with the provided `where` argument, update it with this data.
  **/
  update: productsUpdateInput
}


/**
 * products delete
 */
export type productsDeleteArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter which products to delete.
  **/
  where: productsWhereUniqueInput
}


/**
 * products deleteMany
 */
export type productsDeleteManyArgs = {
  where?: productsWhereInput
}


/**
 * products without action
 */
export type productsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
}



/**
 * Model region
 */

export type region = {
  region_description: string
  region_id: number
}

export type regionSelect = {
  region_description?: boolean
  region_id?: boolean
  territories?: boolean | FindManyterritoriesArgs
}

export type regionInclude = {
  territories?: boolean | FindManyterritoriesArgs
}

export type regionGetPayload<
  S extends boolean | null | undefined | regionArgs,
  U = keyof S
> = S extends true
  ? region
  : S extends undefined
  ? never
  : S extends regionArgs | FindManyregionArgs
  ? 'include' extends U
    ? region  & {
      [P in TrueKeys<S['include']>]:
      P extends 'territories'
      ? Array<territoriesGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof region ? region[P]
: 
      P extends 'territories'
      ? Array<territoriesGetPayload<S['select'][P]>> : never
    }
  : region
: region


export interface regionDelegate {
  /**
   * Find zero or one Region.
   * @param {FindOneregionArgs} args - Arguments to find a Region
   * @example
   * // Get one Region
   * const region = await prisma.region.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneregionArgs>(
    args: Subset<T, FindOneregionArgs>
  ): CheckSelect<T, Prisma__regionClient<region | null>, Prisma__regionClient<regionGetPayload<T> | null>>
  /**
   * Find zero or more Regions.
   * @param {FindManyregionArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Regions
   * const regions = await prisma.region.findMany()
   * 
   * // Get first 10 Regions
   * const regions = await prisma.region.findMany({ take: 10 })
   * 
   * // Only select the `region_description`
   * const regionWithRegion_descriptionOnly = await prisma.region.findMany({ select: { region_description: true } })
   * 
  **/
  findMany<T extends FindManyregionArgs>(
    args?: Subset<T, FindManyregionArgs>
  ): CheckSelect<T, Promise<Array<region>>, Promise<Array<regionGetPayload<T>>>>
  /**
   * Create a Region.
   * @param {regionCreateArgs} args - Arguments to create a Region.
   * @example
   * // Create one Region
   * const Region = await prisma.region.create({
   *   data: {
   *     // ... data to create a Region
   *   }
   * })
   * 
  **/
  create<T extends regionCreateArgs>(
    args: Subset<T, regionCreateArgs>
  ): CheckSelect<T, Prisma__regionClient<region>, Prisma__regionClient<regionGetPayload<T>>>
  /**
   * Delete a Region.
   * @param {regionDeleteArgs} args - Arguments to delete one Region.
   * @example
   * // Delete one Region
   * const Region = await prisma.region.delete({
   *   where: {
   *     // ... filter to delete one Region
   *   }
   * })
   * 
  **/
  delete<T extends regionDeleteArgs>(
    args: Subset<T, regionDeleteArgs>
  ): CheckSelect<T, Prisma__regionClient<region>, Prisma__regionClient<regionGetPayload<T>>>
  /**
   * Update one Region.
   * @param {regionUpdateArgs} args - Arguments to update one Region.
   * @example
   * // Update one Region
   * const region = await prisma.region.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends regionUpdateArgs>(
    args: Subset<T, regionUpdateArgs>
  ): CheckSelect<T, Prisma__regionClient<region>, Prisma__regionClient<regionGetPayload<T>>>
  /**
   * Delete zero or more Regions.
   * @param {regionDeleteManyArgs} args - Arguments to filter Regions to delete.
   * @example
   * // Delete a few Regions
   * const { count } = await prisma.region.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends regionDeleteManyArgs>(
    args: Subset<T, regionDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Regions.
   * @param {regionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Regions
   * const region = await prisma.region.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends regionUpdateManyArgs>(
    args: Subset<T, regionUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Region.
   * @param {regionUpsertArgs} args - Arguments to update or create a Region.
   * @example
   * // Update or create a Region
   * const region = await prisma.region.upsert({
   *   create: {
   *     // ... data to create a Region
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Region we want to update
   *   }
   * })
  **/
  upsert<T extends regionUpsertArgs>(
    args: Subset<T, regionUpsertArgs>
  ): CheckSelect<T, Prisma__regionClient<region>, Prisma__regionClient<regionGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyregionArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for region.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__regionClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  territories<T extends FindManyterritoriesArgs = {}>(args?: Subset<T, FindManyterritoriesArgs>): CheckSelect<T, Promise<Array<territories>>, Promise<Array<territoriesGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * region findOne
 */
export type FindOneregionArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
  /**
   * Filter, which region to fetch.
  **/
  where: regionWhereUniqueInput
}


/**
 * region findMany
 */
export type FindManyregionArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
  /**
   * Filter, which regions to fetch.
  **/
  where?: regionWhereInput
  /**
   * Determine the order of the regions to fetch.
  **/
  orderBy?: regionOrderByInput
  /**
   * Sets the position for listing regions.
  **/
  cursor?: regionWhereUniqueInput
  /**
   * The number of regions to fetch. If negative number, it will take regions before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` regions.
  **/
  skip?: number
}


/**
 * region create
 */
export type regionCreateArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
  /**
   * The data needed to create a region.
  **/
  data: regionCreateInput
}


/**
 * region update
 */
export type regionUpdateArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
  /**
   * The data needed to update a region.
  **/
  data: regionUpdateInput
  /**
   * Choose, which region to update.
  **/
  where: regionWhereUniqueInput
}


/**
 * region updateMany
 */
export type regionUpdateManyArgs = {
  data: regionUpdateManyMutationInput
  where?: regionWhereInput
}


/**
 * region upsert
 */
export type regionUpsertArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
  /**
   * The filter to search for the region to update in case it exists.
  **/
  where: regionWhereUniqueInput
  /**
   * In case the region found by the `where` argument doesn't exist, create a new region with this data.
  **/
  create: regionCreateInput
  /**
   * In case the region was found with the provided `where` argument, update it with this data.
  **/
  update: regionUpdateInput
}


/**
 * region delete
 */
export type regionDeleteArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
  /**
   * Filter which region to delete.
  **/
  where: regionWhereUniqueInput
}


/**
 * region deleteMany
 */
export type regionDeleteManyArgs = {
  where?: regionWhereInput
}


/**
 * region without action
 */
export type regionArgs = {
  /**
   * Select specific fields to fetch from the region
  **/
  select?: regionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: regionInclude | null
}



/**
 * Model shippers
 */

export type shippers = {
  company_name: string
  phone: string | null
  shipper_id: number
}

export type shippersSelect = {
  company_name?: boolean
  phone?: boolean
  shipper_id?: boolean
  orders?: boolean | FindManyordersArgs
}

export type shippersInclude = {
  orders?: boolean | FindManyordersArgs
}

export type shippersGetPayload<
  S extends boolean | null | undefined | shippersArgs,
  U = keyof S
> = S extends true
  ? shippers
  : S extends undefined
  ? never
  : S extends shippersArgs | FindManyshippersArgs
  ? 'include' extends U
    ? shippers  & {
      [P in TrueKeys<S['include']>]:
      P extends 'orders'
      ? Array<ordersGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof shippers ? shippers[P]
: 
      P extends 'orders'
      ? Array<ordersGetPayload<S['select'][P]>> : never
    }
  : shippers
: shippers


export interface shippersDelegate {
  /**
   * Find zero or one Shippers.
   * @param {FindOneshippersArgs} args - Arguments to find a Shippers
   * @example
   * // Get one Shippers
   * const shippers = await prisma.shippers.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneshippersArgs>(
    args: Subset<T, FindOneshippersArgs>
  ): CheckSelect<T, Prisma__shippersClient<shippers | null>, Prisma__shippersClient<shippersGetPayload<T> | null>>
  /**
   * Find zero or more Shippers.
   * @param {FindManyshippersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Shippers
   * const shippers = await prisma.shippers.findMany()
   * 
   * // Get first 10 Shippers
   * const shippers = await prisma.shippers.findMany({ take: 10 })
   * 
   * // Only select the `company_name`
   * const shippersWithCompany_nameOnly = await prisma.shippers.findMany({ select: { company_name: true } })
   * 
  **/
  findMany<T extends FindManyshippersArgs>(
    args?: Subset<T, FindManyshippersArgs>
  ): CheckSelect<T, Promise<Array<shippers>>, Promise<Array<shippersGetPayload<T>>>>
  /**
   * Create a Shippers.
   * @param {shippersCreateArgs} args - Arguments to create a Shippers.
   * @example
   * // Create one Shippers
   * const Shippers = await prisma.shippers.create({
   *   data: {
   *     // ... data to create a Shippers
   *   }
   * })
   * 
  **/
  create<T extends shippersCreateArgs>(
    args: Subset<T, shippersCreateArgs>
  ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>
  /**
   * Delete a Shippers.
   * @param {shippersDeleteArgs} args - Arguments to delete one Shippers.
   * @example
   * // Delete one Shippers
   * const Shippers = await prisma.shippers.delete({
   *   where: {
   *     // ... filter to delete one Shippers
   *   }
   * })
   * 
  **/
  delete<T extends shippersDeleteArgs>(
    args: Subset<T, shippersDeleteArgs>
  ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>
  /**
   * Update one Shippers.
   * @param {shippersUpdateArgs} args - Arguments to update one Shippers.
   * @example
   * // Update one Shippers
   * const shippers = await prisma.shippers.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends shippersUpdateArgs>(
    args: Subset<T, shippersUpdateArgs>
  ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>
  /**
   * Delete zero or more Shippers.
   * @param {shippersDeleteManyArgs} args - Arguments to filter Shippers to delete.
   * @example
   * // Delete a few Shippers
   * const { count } = await prisma.shippers.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends shippersDeleteManyArgs>(
    args: Subset<T, shippersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Shippers.
   * @param {shippersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Shippers
   * const shippers = await prisma.shippers.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends shippersUpdateManyArgs>(
    args: Subset<T, shippersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Shippers.
   * @param {shippersUpsertArgs} args - Arguments to update or create a Shippers.
   * @example
   * // Update or create a Shippers
   * const shippers = await prisma.shippers.upsert({
   *   create: {
   *     // ... data to create a Shippers
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Shippers we want to update
   *   }
   * })
  **/
  upsert<T extends shippersUpsertArgs>(
    args: Subset<T, shippersUpsertArgs>
  ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyshippersArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for shippers.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__shippersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  orders<T extends FindManyordersArgs = {}>(args?: Subset<T, FindManyordersArgs>): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * shippers findOne
 */
export type FindOneshippersArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
  /**
   * Filter, which shippers to fetch.
  **/
  where: shippersWhereUniqueInput
}


/**
 * shippers findMany
 */
export type FindManyshippersArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
  /**
   * Filter, which shippers to fetch.
  **/
  where?: shippersWhereInput
  /**
   * Determine the order of the shippers to fetch.
  **/
  orderBy?: shippersOrderByInput
  /**
   * Sets the position for listing shippers.
  **/
  cursor?: shippersWhereUniqueInput
  /**
   * The number of shippers to fetch. If negative number, it will take shippers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` shippers.
  **/
  skip?: number
}


/**
 * shippers create
 */
export type shippersCreateArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
  /**
   * The data needed to create a shippers.
  **/
  data: shippersCreateInput
}


/**
 * shippers update
 */
export type shippersUpdateArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
  /**
   * The data needed to update a shippers.
  **/
  data: shippersUpdateInput
  /**
   * Choose, which shippers to update.
  **/
  where: shippersWhereUniqueInput
}


/**
 * shippers updateMany
 */
export type shippersUpdateManyArgs = {
  data: shippersUpdateManyMutationInput
  where?: shippersWhereInput
}


/**
 * shippers upsert
 */
export type shippersUpsertArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
  /**
   * The filter to search for the shippers to update in case it exists.
  **/
  where: shippersWhereUniqueInput
  /**
   * In case the shippers found by the `where` argument doesn't exist, create a new shippers with this data.
  **/
  create: shippersCreateInput
  /**
   * In case the shippers was found with the provided `where` argument, update it with this data.
  **/
  update: shippersUpdateInput
}


/**
 * shippers delete
 */
export type shippersDeleteArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
  /**
   * Filter which shippers to delete.
  **/
  where: shippersWhereUniqueInput
}


/**
 * shippers deleteMany
 */
export type shippersDeleteManyArgs = {
  where?: shippersWhereInput
}


/**
 * shippers without action
 */
export type shippersArgs = {
  /**
   * Select specific fields to fetch from the shippers
  **/
  select?: shippersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: shippersInclude | null
}



/**
 * Model suppliers
 */

export type suppliers = {
  address: string | null
  city: string | null
  company_name: string
  contact_name: string | null
  contact_title: string | null
  country: string | null
  fax: string | null
  homepage: string | null
  phone: string | null
  postal_code: string | null
  region: string | null
  supplier_id: number
}

export type suppliersSelect = {
  address?: boolean
  city?: boolean
  company_name?: boolean
  contact_name?: boolean
  contact_title?: boolean
  country?: boolean
  fax?: boolean
  homepage?: boolean
  phone?: boolean
  postal_code?: boolean
  region?: boolean
  supplier_id?: boolean
  products?: boolean | FindManyproductsArgs
}

export type suppliersInclude = {
  products?: boolean | FindManyproductsArgs
}

export type suppliersGetPayload<
  S extends boolean | null | undefined | suppliersArgs,
  U = keyof S
> = S extends true
  ? suppliers
  : S extends undefined
  ? never
  : S extends suppliersArgs | FindManysuppliersArgs
  ? 'include' extends U
    ? suppliers  & {
      [P in TrueKeys<S['include']>]:
      P extends 'products'
      ? Array<productsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof suppliers ? suppliers[P]
: 
      P extends 'products'
      ? Array<productsGetPayload<S['select'][P]>> : never
    }
  : suppliers
: suppliers


export interface suppliersDelegate {
  /**
   * Find zero or one Suppliers.
   * @param {FindOnesuppliersArgs} args - Arguments to find a Suppliers
   * @example
   * // Get one Suppliers
   * const suppliers = await prisma.suppliers.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnesuppliersArgs>(
    args: Subset<T, FindOnesuppliersArgs>
  ): CheckSelect<T, Prisma__suppliersClient<suppliers | null>, Prisma__suppliersClient<suppliersGetPayload<T> | null>>
  /**
   * Find zero or more Suppliers.
   * @param {FindManysuppliersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Suppliers
   * const suppliers = await prisma.suppliers.findMany()
   * 
   * // Get first 10 Suppliers
   * const suppliers = await prisma.suppliers.findMany({ take: 10 })
   * 
   * // Only select the `address`
   * const suppliersWithAddressOnly = await prisma.suppliers.findMany({ select: { address: true } })
   * 
  **/
  findMany<T extends FindManysuppliersArgs>(
    args?: Subset<T, FindManysuppliersArgs>
  ): CheckSelect<T, Promise<Array<suppliers>>, Promise<Array<suppliersGetPayload<T>>>>
  /**
   * Create a Suppliers.
   * @param {suppliersCreateArgs} args - Arguments to create a Suppliers.
   * @example
   * // Create one Suppliers
   * const Suppliers = await prisma.suppliers.create({
   *   data: {
   *     // ... data to create a Suppliers
   *   }
   * })
   * 
  **/
  create<T extends suppliersCreateArgs>(
    args: Subset<T, suppliersCreateArgs>
  ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>
  /**
   * Delete a Suppliers.
   * @param {suppliersDeleteArgs} args - Arguments to delete one Suppliers.
   * @example
   * // Delete one Suppliers
   * const Suppliers = await prisma.suppliers.delete({
   *   where: {
   *     // ... filter to delete one Suppliers
   *   }
   * })
   * 
  **/
  delete<T extends suppliersDeleteArgs>(
    args: Subset<T, suppliersDeleteArgs>
  ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>
  /**
   * Update one Suppliers.
   * @param {suppliersUpdateArgs} args - Arguments to update one Suppliers.
   * @example
   * // Update one Suppliers
   * const suppliers = await prisma.suppliers.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends suppliersUpdateArgs>(
    args: Subset<T, suppliersUpdateArgs>
  ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>
  /**
   * Delete zero or more Suppliers.
   * @param {suppliersDeleteManyArgs} args - Arguments to filter Suppliers to delete.
   * @example
   * // Delete a few Suppliers
   * const { count } = await prisma.suppliers.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends suppliersDeleteManyArgs>(
    args: Subset<T, suppliersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Suppliers.
   * @param {suppliersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Suppliers
   * const suppliers = await prisma.suppliers.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends suppliersUpdateManyArgs>(
    args: Subset<T, suppliersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Suppliers.
   * @param {suppliersUpsertArgs} args - Arguments to update or create a Suppliers.
   * @example
   * // Update or create a Suppliers
   * const suppliers = await prisma.suppliers.upsert({
   *   create: {
   *     // ... data to create a Suppliers
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Suppliers we want to update
   *   }
   * })
  **/
  upsert<T extends suppliersUpsertArgs>(
    args: Subset<T, suppliersUpsertArgs>
  ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManysuppliersArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for suppliers.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__suppliersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  products<T extends FindManyproductsArgs = {}>(args?: Subset<T, FindManyproductsArgs>): CheckSelect<T, Promise<Array<products>>, Promise<Array<productsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * suppliers findOne
 */
export type FindOnesuppliersArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
  /**
   * Filter, which suppliers to fetch.
  **/
  where: suppliersWhereUniqueInput
}


/**
 * suppliers findMany
 */
export type FindManysuppliersArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
  /**
   * Filter, which suppliers to fetch.
  **/
  where?: suppliersWhereInput
  /**
   * Determine the order of the suppliers to fetch.
  **/
  orderBy?: suppliersOrderByInput
  /**
   * Sets the position for listing suppliers.
  **/
  cursor?: suppliersWhereUniqueInput
  /**
   * The number of suppliers to fetch. If negative number, it will take suppliers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` suppliers.
  **/
  skip?: number
}


/**
 * suppliers create
 */
export type suppliersCreateArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
  /**
   * The data needed to create a suppliers.
  **/
  data: suppliersCreateInput
}


/**
 * suppliers update
 */
export type suppliersUpdateArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
  /**
   * The data needed to update a suppliers.
  **/
  data: suppliersUpdateInput
  /**
   * Choose, which suppliers to update.
  **/
  where: suppliersWhereUniqueInput
}


/**
 * suppliers updateMany
 */
export type suppliersUpdateManyArgs = {
  data: suppliersUpdateManyMutationInput
  where?: suppliersWhereInput
}


/**
 * suppliers upsert
 */
export type suppliersUpsertArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
  /**
   * The filter to search for the suppliers to update in case it exists.
  **/
  where: suppliersWhereUniqueInput
  /**
   * In case the suppliers found by the `where` argument doesn't exist, create a new suppliers with this data.
  **/
  create: suppliersCreateInput
  /**
   * In case the suppliers was found with the provided `where` argument, update it with this data.
  **/
  update: suppliersUpdateInput
}


/**
 * suppliers delete
 */
export type suppliersDeleteArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
  /**
   * Filter which suppliers to delete.
  **/
  where: suppliersWhereUniqueInput
}


/**
 * suppliers deleteMany
 */
export type suppliersDeleteManyArgs = {
  where?: suppliersWhereInput
}


/**
 * suppliers without action
 */
export type suppliersArgs = {
  /**
   * Select specific fields to fetch from the suppliers
  **/
  select?: suppliersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: suppliersInclude | null
}



/**
 * Model territories
 */

export type territories = {
  region_id: number
  territory_description: string
  territory_id: string
}

export type territoriesSelect = {
  region_id?: boolean
  territory_description?: boolean
  territory_id?: boolean
  region?: boolean | regionArgs
  employee_territories?: boolean | FindManyemployee_territoriesArgs
}

export type territoriesInclude = {
  region?: boolean | regionArgs
  employee_territories?: boolean | FindManyemployee_territoriesArgs
}

export type territoriesGetPayload<
  S extends boolean | null | undefined | territoriesArgs,
  U = keyof S
> = S extends true
  ? territories
  : S extends undefined
  ? never
  : S extends territoriesArgs | FindManyterritoriesArgs
  ? 'include' extends U
    ? territories  & {
      [P in TrueKeys<S['include']>]:
      P extends 'region'
      ? regionGetPayload<S['include'][P]> :
      P extends 'employee_territories'
      ? Array<employee_territoriesGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof territories ? territories[P]
: 
      P extends 'region'
      ? regionGetPayload<S['select'][P]> :
      P extends 'employee_territories'
      ? Array<employee_territoriesGetPayload<S['select'][P]>> : never
    }
  : territories
: territories


export interface territoriesDelegate {
  /**
   * Find zero or one Territories.
   * @param {FindOneterritoriesArgs} args - Arguments to find a Territories
   * @example
   * // Get one Territories
   * const territories = await prisma.territories.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneterritoriesArgs>(
    args: Subset<T, FindOneterritoriesArgs>
  ): CheckSelect<T, Prisma__territoriesClient<territories | null>, Prisma__territoriesClient<territoriesGetPayload<T> | null>>
  /**
   * Find zero or more Territories.
   * @param {FindManyterritoriesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Territories
   * const territories = await prisma.territories.findMany()
   * 
   * // Get first 10 Territories
   * const territories = await prisma.territories.findMany({ take: 10 })
   * 
   * // Only select the `region_id`
   * const territoriesWithRegion_idOnly = await prisma.territories.findMany({ select: { region_id: true } })
   * 
  **/
  findMany<T extends FindManyterritoriesArgs>(
    args?: Subset<T, FindManyterritoriesArgs>
  ): CheckSelect<T, Promise<Array<territories>>, Promise<Array<territoriesGetPayload<T>>>>
  /**
   * Create a Territories.
   * @param {territoriesCreateArgs} args - Arguments to create a Territories.
   * @example
   * // Create one Territories
   * const Territories = await prisma.territories.create({
   *   data: {
   *     // ... data to create a Territories
   *   }
   * })
   * 
  **/
  create<T extends territoriesCreateArgs>(
    args: Subset<T, territoriesCreateArgs>
  ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>
  /**
   * Delete a Territories.
   * @param {territoriesDeleteArgs} args - Arguments to delete one Territories.
   * @example
   * // Delete one Territories
   * const Territories = await prisma.territories.delete({
   *   where: {
   *     // ... filter to delete one Territories
   *   }
   * })
   * 
  **/
  delete<T extends territoriesDeleteArgs>(
    args: Subset<T, territoriesDeleteArgs>
  ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>
  /**
   * Update one Territories.
   * @param {territoriesUpdateArgs} args - Arguments to update one Territories.
   * @example
   * // Update one Territories
   * const territories = await prisma.territories.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends territoriesUpdateArgs>(
    args: Subset<T, territoriesUpdateArgs>
  ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>
  /**
   * Delete zero or more Territories.
   * @param {territoriesDeleteManyArgs} args - Arguments to filter Territories to delete.
   * @example
   * // Delete a few Territories
   * const { count } = await prisma.territories.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends territoriesDeleteManyArgs>(
    args: Subset<T, territoriesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Territories.
   * @param {territoriesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Territories
   * const territories = await prisma.territories.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends territoriesUpdateManyArgs>(
    args: Subset<T, territoriesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Territories.
   * @param {territoriesUpsertArgs} args - Arguments to update or create a Territories.
   * @example
   * // Update or create a Territories
   * const territories = await prisma.territories.upsert({
   *   create: {
   *     // ... data to create a Territories
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Territories we want to update
   *   }
   * })
  **/
  upsert<T extends territoriesUpsertArgs>(
    args: Subset<T, territoriesUpsertArgs>
  ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyterritoriesArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for territories.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__territoriesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  region<T extends regionArgs = {}>(args?: Subset<T, regionArgs>): CheckSelect<T, Prisma__regionClient<region | null>, Prisma__regionClient<regionGetPayload<T> | null>>;

  employee_territories<T extends FindManyemployee_territoriesArgs = {}>(args?: Subset<T, FindManyemployee_territoriesArgs>): CheckSelect<T, Promise<Array<employee_territories>>, Promise<Array<employee_territoriesGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * territories findOne
 */
export type FindOneterritoriesArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
  /**
   * Filter, which territories to fetch.
  **/
  where: territoriesWhereUniqueInput
}


/**
 * territories findMany
 */
export type FindManyterritoriesArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
  /**
   * Filter, which territories to fetch.
  **/
  where?: territoriesWhereInput
  /**
   * Determine the order of the territories to fetch.
  **/
  orderBy?: territoriesOrderByInput
  /**
   * Sets the position for listing territories.
  **/
  cursor?: territoriesWhereUniqueInput
  /**
   * The number of territories to fetch. If negative number, it will take territories before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` territories.
  **/
  skip?: number
}


/**
 * territories create
 */
export type territoriesCreateArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
  /**
   * The data needed to create a territories.
  **/
  data: territoriesCreateInput
}


/**
 * territories update
 */
export type territoriesUpdateArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
  /**
   * The data needed to update a territories.
  **/
  data: territoriesUpdateInput
  /**
   * Choose, which territories to update.
  **/
  where: territoriesWhereUniqueInput
}


/**
 * territories updateMany
 */
export type territoriesUpdateManyArgs = {
  data: territoriesUpdateManyMutationInput
  where?: territoriesWhereInput
}


/**
 * territories upsert
 */
export type territoriesUpsertArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
  /**
   * The filter to search for the territories to update in case it exists.
  **/
  where: territoriesWhereUniqueInput
  /**
   * In case the territories found by the `where` argument doesn't exist, create a new territories with this data.
  **/
  create: territoriesCreateInput
  /**
   * In case the territories was found with the provided `where` argument, update it with this data.
  **/
  update: territoriesUpdateInput
}


/**
 * territories delete
 */
export type territoriesDeleteArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
  /**
   * Filter which territories to delete.
  **/
  where: territoriesWhereUniqueInput
}


/**
 * territories deleteMany
 */
export type territoriesDeleteManyArgs = {
  where?: territoriesWhereInput
}


/**
 * territories without action
 */
export type territoriesArgs = {
  /**
   * Select specific fields to fetch from the territories
  **/
  select?: territoriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: territoriesInclude | null
}



/**
 * Model us_states
 */

export type us_states = {
  state_abbr: string | null
  state_id: number
  state_name: string | null
  state_region: string | null
}

export type us_statesSelect = {
  state_abbr?: boolean
  state_id?: boolean
  state_name?: boolean
  state_region?: boolean
}

export type us_statesGetPayload<
  S extends boolean | null | undefined | us_statesArgs,
  U = keyof S
> = S extends true
  ? us_states
  : S extends undefined
  ? never
  : S extends us_statesArgs | FindManyus_statesArgs
  ? 'include' extends U
    ? us_states 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof us_states ? us_states[P]
: 
 never
    }
  : us_states
: us_states


export interface us_statesDelegate {
  /**
   * Find zero or one Us_states.
   * @param {FindOneus_statesArgs} args - Arguments to find a Us_states
   * @example
   * // Get one Us_states
   * const us_states = await prisma.us_states.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneus_statesArgs>(
    args: Subset<T, FindOneus_statesArgs>
  ): CheckSelect<T, Prisma__us_statesClient<us_states | null>, Prisma__us_statesClient<us_statesGetPayload<T> | null>>
  /**
   * Find zero or more Us_states.
   * @param {FindManyus_statesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Us_states
   * const us_states = await prisma.us_states.findMany()
   * 
   * // Get first 10 Us_states
   * const us_states = await prisma.us_states.findMany({ take: 10 })
   * 
   * // Only select the `state_abbr`
   * const us_statesWithState_abbrOnly = await prisma.us_states.findMany({ select: { state_abbr: true } })
   * 
  **/
  findMany<T extends FindManyus_statesArgs>(
    args?: Subset<T, FindManyus_statesArgs>
  ): CheckSelect<T, Promise<Array<us_states>>, Promise<Array<us_statesGetPayload<T>>>>
  /**
   * Create a Us_states.
   * @param {us_statesCreateArgs} args - Arguments to create a Us_states.
   * @example
   * // Create one Us_states
   * const Us_states = await prisma.us_states.create({
   *   data: {
   *     // ... data to create a Us_states
   *   }
   * })
   * 
  **/
  create<T extends us_statesCreateArgs>(
    args: Subset<T, us_statesCreateArgs>
  ): CheckSelect<T, Prisma__us_statesClient<us_states>, Prisma__us_statesClient<us_statesGetPayload<T>>>
  /**
   * Delete a Us_states.
   * @param {us_statesDeleteArgs} args - Arguments to delete one Us_states.
   * @example
   * // Delete one Us_states
   * const Us_states = await prisma.us_states.delete({
   *   where: {
   *     // ... filter to delete one Us_states
   *   }
   * })
   * 
  **/
  delete<T extends us_statesDeleteArgs>(
    args: Subset<T, us_statesDeleteArgs>
  ): CheckSelect<T, Prisma__us_statesClient<us_states>, Prisma__us_statesClient<us_statesGetPayload<T>>>
  /**
   * Update one Us_states.
   * @param {us_statesUpdateArgs} args - Arguments to update one Us_states.
   * @example
   * // Update one Us_states
   * const us_states = await prisma.us_states.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends us_statesUpdateArgs>(
    args: Subset<T, us_statesUpdateArgs>
  ): CheckSelect<T, Prisma__us_statesClient<us_states>, Prisma__us_statesClient<us_statesGetPayload<T>>>
  /**
   * Delete zero or more Us_states.
   * @param {us_statesDeleteManyArgs} args - Arguments to filter Us_states to delete.
   * @example
   * // Delete a few Us_states
   * const { count } = await prisma.us_states.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends us_statesDeleteManyArgs>(
    args: Subset<T, us_statesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Us_states.
   * @param {us_statesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Us_states
   * const us_states = await prisma.us_states.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends us_statesUpdateManyArgs>(
    args: Subset<T, us_statesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Us_states.
   * @param {us_statesUpsertArgs} args - Arguments to update or create a Us_states.
   * @example
   * // Update or create a Us_states
   * const us_states = await prisma.us_states.upsert({
   *   create: {
   *     // ... data to create a Us_states
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Us_states we want to update
   *   }
   * })
  **/
  upsert<T extends us_statesUpsertArgs>(
    args: Subset<T, us_statesUpsertArgs>
  ): CheckSelect<T, Prisma__us_statesClient<us_states>, Prisma__us_statesClient<us_statesGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyus_statesArgs, 'select' | 'include'>): Promise<number>
}

/**
 * The delegate class that acts as a "Promise-like" for us_states.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__us_statesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * us_states findOne
 */
export type FindOneus_statesArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
  /**
   * Filter, which us_states to fetch.
  **/
  where: us_statesWhereUniqueInput
}


/**
 * us_states findMany
 */
export type FindManyus_statesArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
  /**
   * Filter, which us_states to fetch.
  **/
  where?: us_statesWhereInput
  /**
   * Determine the order of the us_states to fetch.
  **/
  orderBy?: us_statesOrderByInput
  /**
   * Sets the position for listing us_states.
  **/
  cursor?: us_statesWhereUniqueInput
  /**
   * The number of us_states to fetch. If negative number, it will take us_states before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` us_states.
  **/
  skip?: number
}


/**
 * us_states create
 */
export type us_statesCreateArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
  /**
   * The data needed to create a us_states.
  **/
  data: us_statesCreateInput
}


/**
 * us_states update
 */
export type us_statesUpdateArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
  /**
   * The data needed to update a us_states.
  **/
  data: us_statesUpdateInput
  /**
   * Choose, which us_states to update.
  **/
  where: us_statesWhereUniqueInput
}


/**
 * us_states updateMany
 */
export type us_statesUpdateManyArgs = {
  data: us_statesUpdateManyMutationInput
  where?: us_statesWhereInput
}


/**
 * us_states upsert
 */
export type us_statesUpsertArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
  /**
   * The filter to search for the us_states to update in case it exists.
  **/
  where: us_statesWhereUniqueInput
  /**
   * In case the us_states found by the `where` argument doesn't exist, create a new us_states with this data.
  **/
  create: us_statesCreateInput
  /**
   * In case the us_states was found with the provided `where` argument, update it with this data.
  **/
  update: us_statesUpdateInput
}


/**
 * us_states delete
 */
export type us_statesDeleteArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
  /**
   * Filter which us_states to delete.
  **/
  where: us_statesWhereUniqueInput
}


/**
 * us_states deleteMany
 */
export type us_statesDeleteManyArgs = {
  where?: us_statesWhereInput
}


/**
 * us_states without action
 */
export type us_statesArgs = {
  /**
   * Select specific fields to fetch from the us_states
  **/
  select?: us_statesSelect | null
}



/**
 * Deep Input Types
 */


export type suppliersWhereInput = {
  address?: string | NullableStringFilter | null
  city?: string | NullableStringFilter | null
  company_name?: string | StringFilter
  contact_name?: string | NullableStringFilter | null
  contact_title?: string | NullableStringFilter | null
  country?: string | NullableStringFilter | null
  fax?: string | NullableStringFilter | null
  homepage?: string | NullableStringFilter | null
  phone?: string | NullableStringFilter | null
  postal_code?: string | NullableStringFilter | null
  region?: string | NullableStringFilter | null
  supplier_id?: number | IntFilter
  products?: productsFilter | null
  AND?: Enumerable<suppliersWhereInput>
  OR?: Array<suppliersWhereInput>
  NOT?: Enumerable<suppliersWhereInput>
}

export type customer_demographicsWhereInput = {
  customer_desc?: string | NullableStringFilter | null
  customer_type_id?: string | StringFilter
  customer_customer_demo?: customer_customer_demoFilter | null
  AND?: Enumerable<customer_demographicsWhereInput>
  OR?: Array<customer_demographicsWhereInput>
  NOT?: Enumerable<customer_demographicsWhereInput>
}

export type customer_customer_demoWhereInput = {
  customer_id?: string | StringFilter
  customer_type_id?: string | StringFilter
  AND?: Enumerable<customer_customer_demoWhereInput>
  OR?: Array<customer_customer_demoWhereInput>
  NOT?: Enumerable<customer_customer_demoWhereInput>
  customers?: customersWhereInput | null
  customer_demographics?: customer_demographicsWhereInput | null
}

export type customersWhereInput = {
  address?: string | NullableStringFilter | null
  city?: string | NullableStringFilter | null
  company_name?: string | StringFilter
  contact_name?: string | NullableStringFilter | null
  contact_title?: string | NullableStringFilter | null
  country?: string | NullableStringFilter | null
  customer_id?: string | StringFilter
  fax?: string | NullableStringFilter | null
  phone?: string | NullableStringFilter | null
  postal_code?: string | NullableStringFilter | null
  region?: string | NullableStringFilter | null
  customer_customer_demo?: customer_customer_demoFilter | null
  orders?: ordersFilter | null
  AND?: Enumerable<customersWhereInput>
  OR?: Array<customersWhereInput>
  NOT?: Enumerable<customersWhereInput>
}

export type regionWhereInput = {
  region_description?: string | StringFilter
  region_id?: number | IntFilter
  territories?: territoriesFilter | null
  AND?: Enumerable<regionWhereInput>
  OR?: Array<regionWhereInput>
  NOT?: Enumerable<regionWhereInput>
}

export type territoriesWhereInput = {
  region_id?: number | IntFilter
  territory_description?: string | StringFilter
  territory_id?: string | StringFilter
  employee_territories?: employee_territoriesFilter | null
  AND?: Enumerable<territoriesWhereInput>
  OR?: Array<territoriesWhereInput>
  NOT?: Enumerable<territoriesWhereInput>
  region?: regionWhereInput | null
}

export type employee_territoriesWhereInput = {
  employee_id?: number | IntFilter
  territory_id?: string | StringFilter
  AND?: Enumerable<employee_territoriesWhereInput>
  OR?: Array<employee_territoriesWhereInput>
  NOT?: Enumerable<employee_territoriesWhereInput>
  employees?: employeesWhereInput | null
  territories?: territoriesWhereInput | null
}

export type employeesWhereInput = {
  address?: string | NullableStringFilter | null
  birth_date?: Date | string | NullableDateTimeFilter | null
  city?: string | NullableStringFilter | null
  country?: string | NullableStringFilter | null
  employee_id?: number | IntFilter
  extension?: string | NullableStringFilter | null
  first_name?: string | StringFilter
  hire_date?: Date | string | NullableDateTimeFilter | null
  home_phone?: string | NullableStringFilter | null
  last_name?: string | StringFilter
  notes?: string | NullableStringFilter | null
  photo_path?: string | NullableStringFilter | null
  postal_code?: string | NullableStringFilter | null
  region?: string | NullableStringFilter | null
  reports_to?: number | NullableIntFilter | null
  title?: string | NullableStringFilter | null
  title_of_courtesy?: string | NullableStringFilter | null
  employee_territories?: employee_territoriesFilter | null
  other_employees?: employeesFilter | null
  orders?: ordersFilter | null
  AND?: Enumerable<employeesWhereInput>
  OR?: Array<employeesWhereInput>
  NOT?: Enumerable<employeesWhereInput>
  employees?: employeesWhereInput | null
}

export type shippersWhereInput = {
  company_name?: string | StringFilter
  phone?: string | NullableStringFilter | null
  shipper_id?: number | IntFilter
  orders?: ordersFilter | null
  AND?: Enumerable<shippersWhereInput>
  OR?: Array<shippersWhereInput>
  NOT?: Enumerable<shippersWhereInput>
}

export type ordersWhereInput = {
  customer_id?: string | NullableStringFilter | null
  employee_id?: number | NullableIntFilter | null
  freight?: number | NullableFloatFilter | null
  order_date?: Date | string | NullableDateTimeFilter | null
  order_id?: number | IntFilter
  required_date?: Date | string | NullableDateTimeFilter | null
  ship_address?: string | NullableStringFilter | null
  ship_city?: string | NullableStringFilter | null
  ship_country?: string | NullableStringFilter | null
  ship_name?: string | NullableStringFilter | null
  ship_postal_code?: string | NullableStringFilter | null
  ship_region?: string | NullableStringFilter | null
  ship_via?: number | NullableIntFilter | null
  shipped_date?: Date | string | NullableDateTimeFilter | null
  order_details?: order_detailsFilter | null
  AND?: Enumerable<ordersWhereInput>
  OR?: Array<ordersWhereInput>
  NOT?: Enumerable<ordersWhereInput>
  customers?: customersWhereInput | null
  employees?: employeesWhereInput | null
  shippers?: shippersWhereInput | null
}

export type order_detailsWhereInput = {
  discount?: number | FloatFilter
  order_id?: number | IntFilter
  product_id?: number | IntFilter
  quantity?: number | IntFilter
  unit_price?: number | FloatFilter
  AND?: Enumerable<order_detailsWhereInput>
  OR?: Array<order_detailsWhereInput>
  NOT?: Enumerable<order_detailsWhereInput>
  orders?: ordersWhereInput | null
  products?: productsWhereInput | null
}

export type productsWhereInput = {
  category_id?: number | NullableIntFilter | null
  discontinued?: number | IntFilter
  product_id?: number | IntFilter
  product_name?: string | StringFilter
  quantity_per_unit?: string | NullableStringFilter | null
  reorder_level?: number | NullableIntFilter | null
  supplier_id?: number | NullableIntFilter | null
  unit_price?: number | NullableFloatFilter | null
  units_in_stock?: number | NullableIntFilter | null
  units_on_order?: number | NullableIntFilter | null
  order_details?: order_detailsFilter | null
  AND?: Enumerable<productsWhereInput>
  OR?: Array<productsWhereInput>
  NOT?: Enumerable<productsWhereInput>
  categories?: categoriesWhereInput | null
  suppliers?: suppliersWhereInput | null
}

export type categoriesWhereInput = {
  category_id?: number | IntFilter
  category_name?: string | StringFilter
  description?: string | NullableStringFilter | null
  products?: productsFilter | null
  AND?: Enumerable<categoriesWhereInput>
  OR?: Array<categoriesWhereInput>
  NOT?: Enumerable<categoriesWhereInput>
}

export type categoriesWhereUniqueInput = {
  category_id?: number
}

export type productsWhereUniqueInput = {
  product_id?: number
}

export type Order_idProduct_idCompoundUniqueInput = {
  order_id: number
  product_id: number
}

export type order_detailsWhereUniqueInput = {
  order_id_product_id?: Order_idProduct_idCompoundUniqueInput
}

export type Customer_idCustomer_type_idCompoundUniqueInput = {
  customer_id: string
  customer_type_id: string
}

export type customer_customer_demoWhereUniqueInput = {
  customer_id_customer_type_id?: Customer_idCustomer_type_idCompoundUniqueInput
}

export type ordersWhereUniqueInput = {
  order_id?: number
}

export type Employee_idTerritory_idCompoundUniqueInput = {
  employee_id: number
  territory_id: string
}

export type employee_territoriesWhereUniqueInput = {
  employee_id_territory_id?: Employee_idTerritory_idCompoundUniqueInput
}

export type territoriesWhereUniqueInput = {
  territory_id?: string
}

export type employeesWhereUniqueInput = {
  employee_id?: number
}

export type customer_demographicsWhereUniqueInput = {
  customer_type_id?: string
}

export type customersWhereUniqueInput = {
  customer_id?: string
}

export type regionWhereUniqueInput = {
  region_id?: number
}

export type shippersWhereUniqueInput = {
  shipper_id?: number
}

export type suppliersWhereUniqueInput = {
  supplier_id?: number
}

export type us_statesWhereInput = {
  state_abbr?: string | NullableStringFilter | null
  state_id?: number | IntFilter
  state_name?: string | NullableStringFilter | null
  state_region?: string | NullableStringFilter | null
  AND?: Enumerable<us_statesWhereInput>
  OR?: Array<us_statesWhereInput>
  NOT?: Enumerable<us_statesWhereInput>
}

export type us_statesWhereUniqueInput = {
  state_id?: number
}

export type suppliersCreateWithoutProductsInput = {
  address?: string | null
  city?: string | null
  company_name: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  fax?: string | null
  homepage?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  supplier_id: number
}

export type suppliersCreateOneWithoutProductsInput = {
  create?: suppliersCreateWithoutProductsInput
  connect?: suppliersWhereUniqueInput
}

export type customer_demographicsCreateWithoutCustomer_customer_demoInput = {
  customer_desc?: string | null
  customer_type_id: string
}

export type customer_demographicsCreateOneWithoutCustomer_customer_demoInput = {
  create?: customer_demographicsCreateWithoutCustomer_customer_demoInput
  connect?: customer_demographicsWhereUniqueInput
}

export type customer_customer_demoCreateWithoutCustomersInput = {
  customer_demographics: customer_demographicsCreateOneWithoutCustomer_customer_demoInput
}

export type customer_customer_demoCreateManyWithoutCustomersInput = {
  create?: Enumerable<customer_customer_demoCreateWithoutCustomersInput>
  connect?: Enumerable<customer_customer_demoWhereUniqueInput>
}

export type customersCreateWithoutOrdersInput = {
  address?: string | null
  city?: string | null
  company_name: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  customer_customer_demo?: customer_customer_demoCreateManyWithoutCustomersInput | null
}

export type customersCreateOneWithoutOrdersInput = {
  create?: customersCreateWithoutOrdersInput
  connect?: customersWhereUniqueInput
}

export type regionCreateWithoutTerritoriesInput = {
  region_description: string
  region_id: number
}

export type regionCreateOneWithoutTerritoriesInput = {
  create?: regionCreateWithoutTerritoriesInput
  connect?: regionWhereUniqueInput
}

export type territoriesCreateWithoutEmployee_territoriesInput = {
  territory_description: string
  territory_id: string
  region: regionCreateOneWithoutTerritoriesInput
}

export type territoriesCreateOneWithoutEmployee_territoriesInput = {
  create?: territoriesCreateWithoutEmployee_territoriesInput
  connect?: territoriesWhereUniqueInput
}

export type employee_territoriesCreateWithoutEmployeesInput = {
  territories: territoriesCreateOneWithoutEmployee_territoriesInput
}

export type employee_territoriesCreateManyWithoutEmployeesInput = {
  create?: Enumerable<employee_territoriesCreateWithoutEmployeesInput>
  connect?: Enumerable<employee_territoriesWhereUniqueInput>
}

export type shippersCreateWithoutOrdersInput = {
  company_name: string
  phone?: string | null
  shipper_id: number
}

export type shippersCreateOneWithoutOrdersInput = {
  create?: shippersCreateWithoutOrdersInput
  connect?: shippersWhereUniqueInput
}

export type categoriesCreateWithoutProductsInput = {
  category_id: number
  category_name: string
  description?: string | null
}

export type categoriesCreateOneWithoutProductsInput = {
  create?: categoriesCreateWithoutProductsInput
  connect?: categoriesWhereUniqueInput
}

export type productsCreateWithoutOrder_detailsInput = {
  discontinued: number
  product_id: number
  product_name: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  categories?: categoriesCreateOneWithoutProductsInput | null
  suppliers?: suppliersCreateOneWithoutProductsInput | null
}

export type productsCreateOneWithoutOrder_detailsInput = {
  create?: productsCreateWithoutOrder_detailsInput
  connect?: productsWhereUniqueInput
}

export type order_detailsCreateWithoutOrdersInput = {
  discount: number
  quantity: number
  unit_price: number
  products: productsCreateOneWithoutOrder_detailsInput
}

export type order_detailsCreateManyWithoutOrdersInput = {
  create?: Enumerable<order_detailsCreateWithoutOrdersInput>
  connect?: Enumerable<order_detailsWhereUniqueInput>
}

export type ordersCreateWithoutEmployeesInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput | null
  shippers?: shippersCreateOneWithoutOrdersInput | null
  order_details?: order_detailsCreateManyWithoutOrdersInput | null
}

export type ordersCreateManyWithoutEmployeesInput = {
  create?: Enumerable<ordersCreateWithoutEmployeesInput>
  connect?: Enumerable<ordersWhereUniqueInput>
}

export type employeesCreateWithoutOther_employeesInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id: number
  extension?: string | null
  first_name: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesCreateOneWithoutOther_employeesInput | null
  employee_territories?: employee_territoriesCreateManyWithoutEmployeesInput | null
  orders?: ordersCreateManyWithoutEmployeesInput | null
}

export type employeesCreateOneWithoutOther_employeesInput = {
  create?: employeesCreateWithoutOther_employeesInput
  connect?: employeesWhereUniqueInput
}

export type employeesCreateWithoutEmployeesInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id: number
  extension?: string | null
  first_name: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employee_territories?: employee_territoriesCreateManyWithoutEmployeesInput | null
  other_employees?: employeesCreateManyWithoutEmployeesInput | null
  orders?: ordersCreateManyWithoutEmployeesInput | null
}

export type employeesCreateManyWithoutEmployeesInput = {
  create?: Enumerable<employeesCreateWithoutEmployeesInput>
  connect?: Enumerable<employeesWhereUniqueInput>
}

export type employeesCreateWithoutOrdersInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id: number
  extension?: string | null
  first_name: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesCreateOneWithoutOther_employeesInput | null
  employee_territories?: employee_territoriesCreateManyWithoutEmployeesInput | null
  other_employees?: employeesCreateManyWithoutEmployeesInput | null
}

export type employeesCreateOneWithoutOrdersInput = {
  create?: employeesCreateWithoutOrdersInput
  connect?: employeesWhereUniqueInput
}

export type ordersCreateWithoutOrder_detailsInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput | null
  employees?: employeesCreateOneWithoutOrdersInput | null
  shippers?: shippersCreateOneWithoutOrdersInput | null
}

export type ordersCreateOneWithoutOrder_detailsInput = {
  create?: ordersCreateWithoutOrder_detailsInput
  connect?: ordersWhereUniqueInput
}

export type order_detailsCreateWithoutProductsInput = {
  discount: number
  quantity: number
  unit_price: number
  orders: ordersCreateOneWithoutOrder_detailsInput
}

export type order_detailsCreateManyWithoutProductsInput = {
  create?: Enumerable<order_detailsCreateWithoutProductsInput>
  connect?: Enumerable<order_detailsWhereUniqueInput>
}

export type productsCreateWithoutCategoriesInput = {
  discontinued: number
  product_id: number
  product_name: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  suppliers?: suppliersCreateOneWithoutProductsInput | null
  order_details?: order_detailsCreateManyWithoutProductsInput | null
}

export type productsCreateManyWithoutCategoriesInput = {
  create?: Enumerable<productsCreateWithoutCategoriesInput>
  connect?: Enumerable<productsWhereUniqueInput>
}

export type categoriesCreateInput = {
  category_id: number
  category_name: string
  description?: string | null
  products?: productsCreateManyWithoutCategoriesInput | null
}

export type suppliersUpdateWithoutProductsDataInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  fax?: string | null
  homepage?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  supplier_id?: number
}

export type suppliersUpsertWithoutProductsInput = {
  update: suppliersUpdateWithoutProductsDataInput
  create: suppliersCreateWithoutProductsInput
}

export type suppliersUpdateOneWithoutProductsInput = {
  create?: suppliersCreateWithoutProductsInput
  connect?: suppliersWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: suppliersUpdateWithoutProductsDataInput
  upsert?: suppliersUpsertWithoutProductsInput
}

export type customer_demographicsUpdateWithoutCustomer_customer_demoDataInput = {
  customer_desc?: string | null
  customer_type_id?: string
}

export type customer_demographicsUpsertWithoutCustomer_customer_demoInput = {
  update: customer_demographicsUpdateWithoutCustomer_customer_demoDataInput
  create: customer_demographicsCreateWithoutCustomer_customer_demoInput
}

export type customer_demographicsUpdateOneRequiredWithoutCustomer_customer_demoInput = {
  create?: customer_demographicsCreateWithoutCustomer_customer_demoInput
  connect?: customer_demographicsWhereUniqueInput
  update?: customer_demographicsUpdateWithoutCustomer_customer_demoDataInput
  upsert?: customer_demographicsUpsertWithoutCustomer_customer_demoInput
}

export type customer_customer_demoUpdateWithoutCustomersDataInput = {
  customer_demographics?: customer_demographicsUpdateOneRequiredWithoutCustomer_customer_demoInput
}

export type customer_customer_demoUpdateWithWhereUniqueWithoutCustomersInput = {
  where: customer_customer_demoWhereUniqueInput
  data: customer_customer_demoUpdateWithoutCustomersDataInput
}

export type customer_customer_demoScalarWhereInput = {
  customer_id?: string | StringFilter
  customer_type_id?: string | StringFilter
  AND?: Enumerable<customer_customer_demoScalarWhereInput>
  OR?: Array<customer_customer_demoScalarWhereInput>
  NOT?: Enumerable<customer_customer_demoScalarWhereInput>
}

export type customer_customer_demoUpdateManyDataInput = {

}

export type customer_customer_demoUpdateManyWithWhereNestedInput = {
  where: customer_customer_demoScalarWhereInput
  data: customer_customer_demoUpdateManyDataInput
}

export type customer_customer_demoUpsertWithWhereUniqueWithoutCustomersInput = {
  where: customer_customer_demoWhereUniqueInput
  update: customer_customer_demoUpdateWithoutCustomersDataInput
  create: customer_customer_demoCreateWithoutCustomersInput
}

export type customer_customer_demoUpdateManyWithoutCustomersInput = {
  create?: Enumerable<customer_customer_demoCreateWithoutCustomersInput>
  connect?: Enumerable<customer_customer_demoWhereUniqueInput>
  set?: Enumerable<customer_customer_demoWhereUniqueInput>
  disconnect?: Enumerable<customer_customer_demoWhereUniqueInput>
  delete?: Enumerable<customer_customer_demoWhereUniqueInput>
  update?: Enumerable<customer_customer_demoUpdateWithWhereUniqueWithoutCustomersInput>
  updateMany?: Enumerable<customer_customer_demoUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<customer_customer_demoScalarWhereInput>
  upsert?: Enumerable<customer_customer_demoUpsertWithWhereUniqueWithoutCustomersInput>
}

export type customersUpdateWithoutOrdersDataInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id?: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  customer_customer_demo?: customer_customer_demoUpdateManyWithoutCustomersInput
}

export type customersUpsertWithoutOrdersInput = {
  update: customersUpdateWithoutOrdersDataInput
  create: customersCreateWithoutOrdersInput
}

export type customersUpdateOneWithoutOrdersInput = {
  create?: customersCreateWithoutOrdersInput
  connect?: customersWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: customersUpdateWithoutOrdersDataInput
  upsert?: customersUpsertWithoutOrdersInput
}

export type regionUpdateWithoutTerritoriesDataInput = {
  region_description?: string
  region_id?: number
}

export type regionUpsertWithoutTerritoriesInput = {
  update: regionUpdateWithoutTerritoriesDataInput
  create: regionCreateWithoutTerritoriesInput
}

export type regionUpdateOneRequiredWithoutTerritoriesInput = {
  create?: regionCreateWithoutTerritoriesInput
  connect?: regionWhereUniqueInput
  update?: regionUpdateWithoutTerritoriesDataInput
  upsert?: regionUpsertWithoutTerritoriesInput
}

export type territoriesUpdateWithoutEmployee_territoriesDataInput = {
  territory_description?: string
  territory_id?: string
  region?: regionUpdateOneRequiredWithoutTerritoriesInput
}

export type territoriesUpsertWithoutEmployee_territoriesInput = {
  update: territoriesUpdateWithoutEmployee_territoriesDataInput
  create: territoriesCreateWithoutEmployee_territoriesInput
}

export type territoriesUpdateOneRequiredWithoutEmployee_territoriesInput = {
  create?: territoriesCreateWithoutEmployee_territoriesInput
  connect?: territoriesWhereUniqueInput
  update?: territoriesUpdateWithoutEmployee_territoriesDataInput
  upsert?: territoriesUpsertWithoutEmployee_territoriesInput
}

export type employee_territoriesUpdateWithoutEmployeesDataInput = {
  territories?: territoriesUpdateOneRequiredWithoutEmployee_territoriesInput
}

export type employee_territoriesUpdateWithWhereUniqueWithoutEmployeesInput = {
  where: employee_territoriesWhereUniqueInput
  data: employee_territoriesUpdateWithoutEmployeesDataInput
}

export type employee_territoriesScalarWhereInput = {
  employee_id?: number | IntFilter
  territory_id?: string | StringFilter
  AND?: Enumerable<employee_territoriesScalarWhereInput>
  OR?: Array<employee_territoriesScalarWhereInput>
  NOT?: Enumerable<employee_territoriesScalarWhereInput>
}

export type employee_territoriesUpdateManyDataInput = {

}

export type employee_territoriesUpdateManyWithWhereNestedInput = {
  where: employee_territoriesScalarWhereInput
  data: employee_territoriesUpdateManyDataInput
}

export type employee_territoriesUpsertWithWhereUniqueWithoutEmployeesInput = {
  where: employee_territoriesWhereUniqueInput
  update: employee_territoriesUpdateWithoutEmployeesDataInput
  create: employee_territoriesCreateWithoutEmployeesInput
}

export type employee_territoriesUpdateManyWithoutEmployeesInput = {
  create?: Enumerable<employee_territoriesCreateWithoutEmployeesInput>
  connect?: Enumerable<employee_territoriesWhereUniqueInput>
  set?: Enumerable<employee_territoriesWhereUniqueInput>
  disconnect?: Enumerable<employee_territoriesWhereUniqueInput>
  delete?: Enumerable<employee_territoriesWhereUniqueInput>
  update?: Enumerable<employee_territoriesUpdateWithWhereUniqueWithoutEmployeesInput>
  updateMany?: Enumerable<employee_territoriesUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<employee_territoriesScalarWhereInput>
  upsert?: Enumerable<employee_territoriesUpsertWithWhereUniqueWithoutEmployeesInput>
}

export type shippersUpdateWithoutOrdersDataInput = {
  company_name?: string
  phone?: string | null
  shipper_id?: number
}

export type shippersUpsertWithoutOrdersInput = {
  update: shippersUpdateWithoutOrdersDataInput
  create: shippersCreateWithoutOrdersInput
}

export type shippersUpdateOneWithoutOrdersInput = {
  create?: shippersCreateWithoutOrdersInput
  connect?: shippersWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: shippersUpdateWithoutOrdersDataInput
  upsert?: shippersUpsertWithoutOrdersInput
}

export type categoriesUpdateWithoutProductsDataInput = {
  category_id?: number
  category_name?: string
  description?: string | null
}

export type categoriesUpsertWithoutProductsInput = {
  update: categoriesUpdateWithoutProductsDataInput
  create: categoriesCreateWithoutProductsInput
}

export type categoriesUpdateOneWithoutProductsInput = {
  create?: categoriesCreateWithoutProductsInput
  connect?: categoriesWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: categoriesUpdateWithoutProductsDataInput
  upsert?: categoriesUpsertWithoutProductsInput
}

export type productsUpdateWithoutOrder_detailsDataInput = {
  discontinued?: number
  product_id?: number
  product_name?: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  categories?: categoriesUpdateOneWithoutProductsInput
  suppliers?: suppliersUpdateOneWithoutProductsInput
}

export type productsUpsertWithoutOrder_detailsInput = {
  update: productsUpdateWithoutOrder_detailsDataInput
  create: productsCreateWithoutOrder_detailsInput
}

export type productsUpdateOneRequiredWithoutOrder_detailsInput = {
  create?: productsCreateWithoutOrder_detailsInput
  connect?: productsWhereUniqueInput
  update?: productsUpdateWithoutOrder_detailsDataInput
  upsert?: productsUpsertWithoutOrder_detailsInput
}

export type order_detailsUpdateWithoutOrdersDataInput = {
  discount?: number
  quantity?: number
  unit_price?: number
  products?: productsUpdateOneRequiredWithoutOrder_detailsInput
}

export type order_detailsUpdateWithWhereUniqueWithoutOrdersInput = {
  where: order_detailsWhereUniqueInput
  data: order_detailsUpdateWithoutOrdersDataInput
}

export type order_detailsScalarWhereInput = {
  discount?: number | FloatFilter
  order_id?: number | IntFilter
  product_id?: number | IntFilter
  quantity?: number | IntFilter
  unit_price?: number | FloatFilter
  AND?: Enumerable<order_detailsScalarWhereInput>
  OR?: Array<order_detailsScalarWhereInput>
  NOT?: Enumerable<order_detailsScalarWhereInput>
}

export type order_detailsUpdateManyDataInput = {
  discount?: number
  quantity?: number
  unit_price?: number
}

export type order_detailsUpdateManyWithWhereNestedInput = {
  where: order_detailsScalarWhereInput
  data: order_detailsUpdateManyDataInput
}

export type order_detailsUpsertWithWhereUniqueWithoutOrdersInput = {
  where: order_detailsWhereUniqueInput
  update: order_detailsUpdateWithoutOrdersDataInput
  create: order_detailsCreateWithoutOrdersInput
}

export type order_detailsUpdateManyWithoutOrdersInput = {
  create?: Enumerable<order_detailsCreateWithoutOrdersInput>
  connect?: Enumerable<order_detailsWhereUniqueInput>
  set?: Enumerable<order_detailsWhereUniqueInput>
  disconnect?: Enumerable<order_detailsWhereUniqueInput>
  delete?: Enumerable<order_detailsWhereUniqueInput>
  update?: Enumerable<order_detailsUpdateWithWhereUniqueWithoutOrdersInput>
  updateMany?: Enumerable<order_detailsUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<order_detailsScalarWhereInput>
  upsert?: Enumerable<order_detailsUpsertWithWhereUniqueWithoutOrdersInput>
}

export type ordersUpdateWithoutEmployeesDataInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersUpdateOneWithoutOrdersInput
  shippers?: shippersUpdateOneWithoutOrdersInput
  order_details?: order_detailsUpdateManyWithoutOrdersInput
}

export type ordersUpdateWithWhereUniqueWithoutEmployeesInput = {
  where: ordersWhereUniqueInput
  data: ordersUpdateWithoutEmployeesDataInput
}

export type ordersScalarWhereInput = {
  customer_id?: string | NullableStringFilter | null
  employee_id?: number | NullableIntFilter | null
  freight?: number | NullableFloatFilter | null
  order_date?: Date | string | NullableDateTimeFilter | null
  order_id?: number | IntFilter
  required_date?: Date | string | NullableDateTimeFilter | null
  ship_address?: string | NullableStringFilter | null
  ship_city?: string | NullableStringFilter | null
  ship_country?: string | NullableStringFilter | null
  ship_name?: string | NullableStringFilter | null
  ship_postal_code?: string | NullableStringFilter | null
  ship_region?: string | NullableStringFilter | null
  ship_via?: number | NullableIntFilter | null
  shipped_date?: Date | string | NullableDateTimeFilter | null
  order_details?: order_detailsFilter | null
  AND?: Enumerable<ordersScalarWhereInput>
  OR?: Array<ordersScalarWhereInput>
  NOT?: Enumerable<ordersScalarWhereInput>
}

export type ordersUpdateManyDataInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
}

export type ordersUpdateManyWithWhereNestedInput = {
  where: ordersScalarWhereInput
  data: ordersUpdateManyDataInput
}

export type ordersUpsertWithWhereUniqueWithoutEmployeesInput = {
  where: ordersWhereUniqueInput
  update: ordersUpdateWithoutEmployeesDataInput
  create: ordersCreateWithoutEmployeesInput
}

export type ordersUpdateManyWithoutEmployeesInput = {
  create?: Enumerable<ordersCreateWithoutEmployeesInput>
  connect?: Enumerable<ordersWhereUniqueInput>
  set?: Enumerable<ordersWhereUniqueInput>
  disconnect?: Enumerable<ordersWhereUniqueInput>
  delete?: Enumerable<ordersWhereUniqueInput>
  update?: Enumerable<ordersUpdateWithWhereUniqueWithoutEmployeesInput>
  updateMany?: Enumerable<ordersUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<ordersScalarWhereInput>
  upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutEmployeesInput>
}

export type employeesUpdateWithoutOther_employeesDataInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesUpdateOneWithoutOther_employeesInput
  employee_territories?: employee_territoriesUpdateManyWithoutEmployeesInput
  orders?: ordersUpdateManyWithoutEmployeesInput
}

export type employeesUpsertWithoutOther_employeesInput = {
  update: employeesUpdateWithoutOther_employeesDataInput
  create: employeesCreateWithoutOther_employeesInput
}

export type employeesUpdateOneWithoutOther_employeesInput = {
  create?: employeesCreateWithoutOther_employeesInput
  connect?: employeesWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: employeesUpdateWithoutOther_employeesDataInput
  upsert?: employeesUpsertWithoutOther_employeesInput
}

export type employeesUpdateWithoutEmployeesDataInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employee_territories?: employee_territoriesUpdateManyWithoutEmployeesInput
  other_employees?: employeesUpdateManyWithoutEmployeesInput
  orders?: ordersUpdateManyWithoutEmployeesInput
}

export type employeesUpdateWithWhereUniqueWithoutEmployeesInput = {
  where: employeesWhereUniqueInput
  data: employeesUpdateWithoutEmployeesDataInput
}

export type employeesScalarWhereInput = {
  address?: string | NullableStringFilter | null
  birth_date?: Date | string | NullableDateTimeFilter | null
  city?: string | NullableStringFilter | null
  country?: string | NullableStringFilter | null
  employee_id?: number | IntFilter
  extension?: string | NullableStringFilter | null
  first_name?: string | StringFilter
  hire_date?: Date | string | NullableDateTimeFilter | null
  home_phone?: string | NullableStringFilter | null
  last_name?: string | StringFilter
  notes?: string | NullableStringFilter | null
  photo_path?: string | NullableStringFilter | null
  postal_code?: string | NullableStringFilter | null
  region?: string | NullableStringFilter | null
  reports_to?: number | NullableIntFilter | null
  title?: string | NullableStringFilter | null
  title_of_courtesy?: string | NullableStringFilter | null
  employee_territories?: employee_territoriesFilter | null
  other_employees?: employeesFilter | null
  orders?: ordersFilter | null
  AND?: Enumerable<employeesScalarWhereInput>
  OR?: Array<employeesScalarWhereInput>
  NOT?: Enumerable<employeesScalarWhereInput>
}

export type employeesUpdateManyDataInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
}

export type employeesUpdateManyWithWhereNestedInput = {
  where: employeesScalarWhereInput
  data: employeesUpdateManyDataInput
}

export type employeesUpsertWithWhereUniqueWithoutEmployeesInput = {
  where: employeesWhereUniqueInput
  update: employeesUpdateWithoutEmployeesDataInput
  create: employeesCreateWithoutEmployeesInput
}

export type employeesUpdateManyWithoutEmployeesInput = {
  create?: Enumerable<employeesCreateWithoutEmployeesInput>
  connect?: Enumerable<employeesWhereUniqueInput>
  set?: Enumerable<employeesWhereUniqueInput>
  disconnect?: Enumerable<employeesWhereUniqueInput>
  delete?: Enumerable<employeesWhereUniqueInput>
  update?: Enumerable<employeesUpdateWithWhereUniqueWithoutEmployeesInput>
  updateMany?: Enumerable<employeesUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<employeesScalarWhereInput>
  upsert?: Enumerable<employeesUpsertWithWhereUniqueWithoutEmployeesInput>
}

export type employeesUpdateWithoutOrdersDataInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesUpdateOneWithoutOther_employeesInput
  employee_territories?: employee_territoriesUpdateManyWithoutEmployeesInput
  other_employees?: employeesUpdateManyWithoutEmployeesInput
}

export type employeesUpsertWithoutOrdersInput = {
  update: employeesUpdateWithoutOrdersDataInput
  create: employeesCreateWithoutOrdersInput
}

export type employeesUpdateOneWithoutOrdersInput = {
  create?: employeesCreateWithoutOrdersInput
  connect?: employeesWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: employeesUpdateWithoutOrdersDataInput
  upsert?: employeesUpsertWithoutOrdersInput
}

export type ordersUpdateWithoutOrder_detailsDataInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersUpdateOneWithoutOrdersInput
  employees?: employeesUpdateOneWithoutOrdersInput
  shippers?: shippersUpdateOneWithoutOrdersInput
}

export type ordersUpsertWithoutOrder_detailsInput = {
  update: ordersUpdateWithoutOrder_detailsDataInput
  create: ordersCreateWithoutOrder_detailsInput
}

export type ordersUpdateOneRequiredWithoutOrder_detailsInput = {
  create?: ordersCreateWithoutOrder_detailsInput
  connect?: ordersWhereUniqueInput
  update?: ordersUpdateWithoutOrder_detailsDataInput
  upsert?: ordersUpsertWithoutOrder_detailsInput
}

export type order_detailsUpdateWithoutProductsDataInput = {
  discount?: number
  quantity?: number
  unit_price?: number
  orders?: ordersUpdateOneRequiredWithoutOrder_detailsInput
}

export type order_detailsUpdateWithWhereUniqueWithoutProductsInput = {
  where: order_detailsWhereUniqueInput
  data: order_detailsUpdateWithoutProductsDataInput
}

export type order_detailsUpsertWithWhereUniqueWithoutProductsInput = {
  where: order_detailsWhereUniqueInput
  update: order_detailsUpdateWithoutProductsDataInput
  create: order_detailsCreateWithoutProductsInput
}

export type order_detailsUpdateManyWithoutProductsInput = {
  create?: Enumerable<order_detailsCreateWithoutProductsInput>
  connect?: Enumerable<order_detailsWhereUniqueInput>
  set?: Enumerable<order_detailsWhereUniqueInput>
  disconnect?: Enumerable<order_detailsWhereUniqueInput>
  delete?: Enumerable<order_detailsWhereUniqueInput>
  update?: Enumerable<order_detailsUpdateWithWhereUniqueWithoutProductsInput>
  updateMany?: Enumerable<order_detailsUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<order_detailsScalarWhereInput>
  upsert?: Enumerable<order_detailsUpsertWithWhereUniqueWithoutProductsInput>
}

export type productsUpdateWithoutCategoriesDataInput = {
  discontinued?: number
  product_id?: number
  product_name?: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  suppliers?: suppliersUpdateOneWithoutProductsInput
  order_details?: order_detailsUpdateManyWithoutProductsInput
}

export type productsUpdateWithWhereUniqueWithoutCategoriesInput = {
  where: productsWhereUniqueInput
  data: productsUpdateWithoutCategoriesDataInput
}

export type productsScalarWhereInput = {
  category_id?: number | NullableIntFilter | null
  discontinued?: number | IntFilter
  product_id?: number | IntFilter
  product_name?: string | StringFilter
  quantity_per_unit?: string | NullableStringFilter | null
  reorder_level?: number | NullableIntFilter | null
  supplier_id?: number | NullableIntFilter | null
  unit_price?: number | NullableFloatFilter | null
  units_in_stock?: number | NullableIntFilter | null
  units_on_order?: number | NullableIntFilter | null
  order_details?: order_detailsFilter | null
  AND?: Enumerable<productsScalarWhereInput>
  OR?: Array<productsScalarWhereInput>
  NOT?: Enumerable<productsScalarWhereInput>
}

export type productsUpdateManyDataInput = {
  discontinued?: number
  product_id?: number
  product_name?: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
}

export type productsUpdateManyWithWhereNestedInput = {
  where: productsScalarWhereInput
  data: productsUpdateManyDataInput
}

export type productsUpsertWithWhereUniqueWithoutCategoriesInput = {
  where: productsWhereUniqueInput
  update: productsUpdateWithoutCategoriesDataInput
  create: productsCreateWithoutCategoriesInput
}

export type productsUpdateManyWithoutCategoriesInput = {
  create?: Enumerable<productsCreateWithoutCategoriesInput>
  connect?: Enumerable<productsWhereUniqueInput>
  set?: Enumerable<productsWhereUniqueInput>
  disconnect?: Enumerable<productsWhereUniqueInput>
  delete?: Enumerable<productsWhereUniqueInput>
  update?: Enumerable<productsUpdateWithWhereUniqueWithoutCategoriesInput>
  updateMany?: Enumerable<productsUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<productsScalarWhereInput>
  upsert?: Enumerable<productsUpsertWithWhereUniqueWithoutCategoriesInput>
}

export type categoriesUpdateInput = {
  category_id?: number
  category_name?: string
  description?: string | null
  products?: productsUpdateManyWithoutCategoriesInput
}

export type categoriesUpdateManyMutationInput = {
  category_id?: number
  category_name?: string
  description?: string | null
}

export type ordersCreateWithoutCustomersInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  employees?: employeesCreateOneWithoutOrdersInput | null
  shippers?: shippersCreateOneWithoutOrdersInput | null
  order_details?: order_detailsCreateManyWithoutOrdersInput | null
}

export type ordersCreateManyWithoutCustomersInput = {
  create?: Enumerable<ordersCreateWithoutCustomersInput>
  connect?: Enumerable<ordersWhereUniqueInput>
}

export type customersCreateWithoutCustomer_customer_demoInput = {
  address?: string | null
  city?: string | null
  company_name: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  orders?: ordersCreateManyWithoutCustomersInput | null
}

export type customersCreateOneWithoutCustomer_customer_demoInput = {
  create?: customersCreateWithoutCustomer_customer_demoInput
  connect?: customersWhereUniqueInput
}

export type customer_customer_demoCreateInput = {
  customers: customersCreateOneWithoutCustomer_customer_demoInput
  customer_demographics: customer_demographicsCreateOneWithoutCustomer_customer_demoInput
}

export type ordersUpdateWithoutCustomersDataInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  employees?: employeesUpdateOneWithoutOrdersInput
  shippers?: shippersUpdateOneWithoutOrdersInput
  order_details?: order_detailsUpdateManyWithoutOrdersInput
}

export type ordersUpdateWithWhereUniqueWithoutCustomersInput = {
  where: ordersWhereUniqueInput
  data: ordersUpdateWithoutCustomersDataInput
}

export type ordersUpsertWithWhereUniqueWithoutCustomersInput = {
  where: ordersWhereUniqueInput
  update: ordersUpdateWithoutCustomersDataInput
  create: ordersCreateWithoutCustomersInput
}

export type ordersUpdateManyWithoutCustomersInput = {
  create?: Enumerable<ordersCreateWithoutCustomersInput>
  connect?: Enumerable<ordersWhereUniqueInput>
  set?: Enumerable<ordersWhereUniqueInput>
  disconnect?: Enumerable<ordersWhereUniqueInput>
  delete?: Enumerable<ordersWhereUniqueInput>
  update?: Enumerable<ordersUpdateWithWhereUniqueWithoutCustomersInput>
  updateMany?: Enumerable<ordersUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<ordersScalarWhereInput>
  upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutCustomersInput>
}

export type customersUpdateWithoutCustomer_customer_demoDataInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id?: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  orders?: ordersUpdateManyWithoutCustomersInput
}

export type customersUpsertWithoutCustomer_customer_demoInput = {
  update: customersUpdateWithoutCustomer_customer_demoDataInput
  create: customersCreateWithoutCustomer_customer_demoInput
}

export type customersUpdateOneRequiredWithoutCustomer_customer_demoInput = {
  create?: customersCreateWithoutCustomer_customer_demoInput
  connect?: customersWhereUniqueInput
  update?: customersUpdateWithoutCustomer_customer_demoDataInput
  upsert?: customersUpsertWithoutCustomer_customer_demoInput
}

export type customer_customer_demoUpdateInput = {
  customers?: customersUpdateOneRequiredWithoutCustomer_customer_demoInput
  customer_demographics?: customer_demographicsUpdateOneRequiredWithoutCustomer_customer_demoInput
}

export type customer_customer_demoUpdateManyMutationInput = {

}

export type customer_customer_demoCreateWithoutCustomer_demographicsInput = {
  customers: customersCreateOneWithoutCustomer_customer_demoInput
}

export type customer_customer_demoCreateManyWithoutCustomer_demographicsInput = {
  create?: Enumerable<customer_customer_demoCreateWithoutCustomer_demographicsInput>
  connect?: Enumerable<customer_customer_demoWhereUniqueInput>
}

export type customer_demographicsCreateInput = {
  customer_desc?: string | null
  customer_type_id: string
  customer_customer_demo?: customer_customer_demoCreateManyWithoutCustomer_demographicsInput | null
}

export type customer_customer_demoUpdateWithoutCustomer_demographicsDataInput = {
  customers?: customersUpdateOneRequiredWithoutCustomer_customer_demoInput
}

export type customer_customer_demoUpdateWithWhereUniqueWithoutCustomer_demographicsInput = {
  where: customer_customer_demoWhereUniqueInput
  data: customer_customer_demoUpdateWithoutCustomer_demographicsDataInput
}

export type customer_customer_demoUpsertWithWhereUniqueWithoutCustomer_demographicsInput = {
  where: customer_customer_demoWhereUniqueInput
  update: customer_customer_demoUpdateWithoutCustomer_demographicsDataInput
  create: customer_customer_demoCreateWithoutCustomer_demographicsInput
}

export type customer_customer_demoUpdateManyWithoutCustomer_demographicsInput = {
  create?: Enumerable<customer_customer_demoCreateWithoutCustomer_demographicsInput>
  connect?: Enumerable<customer_customer_demoWhereUniqueInput>
  set?: Enumerable<customer_customer_demoWhereUniqueInput>
  disconnect?: Enumerable<customer_customer_demoWhereUniqueInput>
  delete?: Enumerable<customer_customer_demoWhereUniqueInput>
  update?: Enumerable<customer_customer_demoUpdateWithWhereUniqueWithoutCustomer_demographicsInput>
  updateMany?: Enumerable<customer_customer_demoUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<customer_customer_demoScalarWhereInput>
  upsert?: Enumerable<customer_customer_demoUpsertWithWhereUniqueWithoutCustomer_demographicsInput>
}

export type customer_demographicsUpdateInput = {
  customer_desc?: string | null
  customer_type_id?: string
  customer_customer_demo?: customer_customer_demoUpdateManyWithoutCustomer_demographicsInput
}

export type customer_demographicsUpdateManyMutationInput = {
  customer_desc?: string | null
  customer_type_id?: string
}

export type customersCreateInput = {
  address?: string | null
  city?: string | null
  company_name: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  customer_customer_demo?: customer_customer_demoCreateManyWithoutCustomersInput | null
  orders?: ordersCreateManyWithoutCustomersInput | null
}

export type customersUpdateInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id?: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  customer_customer_demo?: customer_customer_demoUpdateManyWithoutCustomersInput
  orders?: ordersUpdateManyWithoutCustomersInput
}

export type customersUpdateManyMutationInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  customer_id?: string
  fax?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
}

export type employeesCreateWithoutEmployee_territoriesInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id: number
  extension?: string | null
  first_name: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesCreateOneWithoutOther_employeesInput | null
  other_employees?: employeesCreateManyWithoutEmployeesInput | null
  orders?: ordersCreateManyWithoutEmployeesInput | null
}

export type employeesCreateOneWithoutEmployee_territoriesInput = {
  create?: employeesCreateWithoutEmployee_territoriesInput
  connect?: employeesWhereUniqueInput
}

export type employee_territoriesCreateInput = {
  employees: employeesCreateOneWithoutEmployee_territoriesInput
  territories: territoriesCreateOneWithoutEmployee_territoriesInput
}

export type employeesUpdateWithoutEmployee_territoriesDataInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesUpdateOneWithoutOther_employeesInput
  other_employees?: employeesUpdateManyWithoutEmployeesInput
  orders?: ordersUpdateManyWithoutEmployeesInput
}

export type employeesUpsertWithoutEmployee_territoriesInput = {
  update: employeesUpdateWithoutEmployee_territoriesDataInput
  create: employeesCreateWithoutEmployee_territoriesInput
}

export type employeesUpdateOneRequiredWithoutEmployee_territoriesInput = {
  create?: employeesCreateWithoutEmployee_territoriesInput
  connect?: employeesWhereUniqueInput
  update?: employeesUpdateWithoutEmployee_territoriesDataInput
  upsert?: employeesUpsertWithoutEmployee_territoriesInput
}

export type employee_territoriesUpdateInput = {
  employees?: employeesUpdateOneRequiredWithoutEmployee_territoriesInput
  territories?: territoriesUpdateOneRequiredWithoutEmployee_territoriesInput
}

export type employee_territoriesUpdateManyMutationInput = {

}

export type employeesCreateInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id: number
  extension?: string | null
  first_name: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesCreateOneWithoutOther_employeesInput | null
  employee_territories?: employee_territoriesCreateManyWithoutEmployeesInput | null
  other_employees?: employeesCreateManyWithoutEmployeesInput | null
  orders?: ordersCreateManyWithoutEmployeesInput | null
}

export type employeesUpdateInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
  employees?: employeesUpdateOneWithoutOther_employeesInput
  employee_territories?: employee_territoriesUpdateManyWithoutEmployeesInput
  other_employees?: employeesUpdateManyWithoutEmployeesInput
  orders?: ordersUpdateManyWithoutEmployeesInput
}

export type employeesUpdateManyMutationInput = {
  address?: string | null
  birth_date?: Date | string | null
  city?: string | null
  country?: string | null
  employee_id?: number
  extension?: string | null
  first_name?: string
  hire_date?: Date | string | null
  home_phone?: string | null
  last_name?: string
  notes?: string | null
  photo_path?: string | null
  postal_code?: string | null
  region?: string | null
  title?: string | null
  title_of_courtesy?: string | null
}

export type order_detailsCreateInput = {
  discount: number
  quantity: number
  unit_price: number
  orders: ordersCreateOneWithoutOrder_detailsInput
  products: productsCreateOneWithoutOrder_detailsInput
}

export type order_detailsUpdateInput = {
  discount?: number
  quantity?: number
  unit_price?: number
  orders?: ordersUpdateOneRequiredWithoutOrder_detailsInput
  products?: productsUpdateOneRequiredWithoutOrder_detailsInput
}

export type order_detailsUpdateManyMutationInput = {
  discount?: number
  quantity?: number
  unit_price?: number
}

export type ordersCreateInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput | null
  employees?: employeesCreateOneWithoutOrdersInput | null
  shippers?: shippersCreateOneWithoutOrdersInput | null
  order_details?: order_detailsCreateManyWithoutOrdersInput | null
}

export type ordersUpdateInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersUpdateOneWithoutOrdersInput
  employees?: employeesUpdateOneWithoutOrdersInput
  shippers?: shippersUpdateOneWithoutOrdersInput
  order_details?: order_detailsUpdateManyWithoutOrdersInput
}

export type ordersUpdateManyMutationInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
}

export type productsCreateInput = {
  discontinued: number
  product_id: number
  product_name: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  categories?: categoriesCreateOneWithoutProductsInput | null
  suppliers?: suppliersCreateOneWithoutProductsInput | null
  order_details?: order_detailsCreateManyWithoutProductsInput | null
}

export type productsUpdateInput = {
  discontinued?: number
  product_id?: number
  product_name?: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  categories?: categoriesUpdateOneWithoutProductsInput
  suppliers?: suppliersUpdateOneWithoutProductsInput
  order_details?: order_detailsUpdateManyWithoutProductsInput
}

export type productsUpdateManyMutationInput = {
  discontinued?: number
  product_id?: number
  product_name?: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
}

export type employee_territoriesCreateWithoutTerritoriesInput = {
  employees: employeesCreateOneWithoutEmployee_territoriesInput
}

export type employee_territoriesCreateManyWithoutTerritoriesInput = {
  create?: Enumerable<employee_territoriesCreateWithoutTerritoriesInput>
  connect?: Enumerable<employee_territoriesWhereUniqueInput>
}

export type territoriesCreateWithoutRegionInput = {
  territory_description: string
  territory_id: string
  employee_territories?: employee_territoriesCreateManyWithoutTerritoriesInput | null
}

export type territoriesCreateManyWithoutRegionInput = {
  create?: Enumerable<territoriesCreateWithoutRegionInput>
  connect?: Enumerable<territoriesWhereUniqueInput>
}

export type regionCreateInput = {
  region_description: string
  region_id: number
  territories?: territoriesCreateManyWithoutRegionInput | null
}

export type employee_territoriesUpdateWithoutTerritoriesDataInput = {
  employees?: employeesUpdateOneRequiredWithoutEmployee_territoriesInput
}

export type employee_territoriesUpdateWithWhereUniqueWithoutTerritoriesInput = {
  where: employee_territoriesWhereUniqueInput
  data: employee_territoriesUpdateWithoutTerritoriesDataInput
}

export type employee_territoriesUpsertWithWhereUniqueWithoutTerritoriesInput = {
  where: employee_territoriesWhereUniqueInput
  update: employee_territoriesUpdateWithoutTerritoriesDataInput
  create: employee_territoriesCreateWithoutTerritoriesInput
}

export type employee_territoriesUpdateManyWithoutTerritoriesInput = {
  create?: Enumerable<employee_territoriesCreateWithoutTerritoriesInput>
  connect?: Enumerable<employee_territoriesWhereUniqueInput>
  set?: Enumerable<employee_territoriesWhereUniqueInput>
  disconnect?: Enumerable<employee_territoriesWhereUniqueInput>
  delete?: Enumerable<employee_territoriesWhereUniqueInput>
  update?: Enumerable<employee_territoriesUpdateWithWhereUniqueWithoutTerritoriesInput>
  updateMany?: Enumerable<employee_territoriesUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<employee_territoriesScalarWhereInput>
  upsert?: Enumerable<employee_territoriesUpsertWithWhereUniqueWithoutTerritoriesInput>
}

export type territoriesUpdateWithoutRegionDataInput = {
  territory_description?: string
  territory_id?: string
  employee_territories?: employee_territoriesUpdateManyWithoutTerritoriesInput
}

export type territoriesUpdateWithWhereUniqueWithoutRegionInput = {
  where: territoriesWhereUniqueInput
  data: territoriesUpdateWithoutRegionDataInput
}

export type territoriesScalarWhereInput = {
  region_id?: number | IntFilter
  territory_description?: string | StringFilter
  territory_id?: string | StringFilter
  employee_territories?: employee_territoriesFilter | null
  AND?: Enumerable<territoriesScalarWhereInput>
  OR?: Array<territoriesScalarWhereInput>
  NOT?: Enumerable<territoriesScalarWhereInput>
}

export type territoriesUpdateManyDataInput = {
  territory_description?: string
  territory_id?: string
}

export type territoriesUpdateManyWithWhereNestedInput = {
  where: territoriesScalarWhereInput
  data: territoriesUpdateManyDataInput
}

export type territoriesUpsertWithWhereUniqueWithoutRegionInput = {
  where: territoriesWhereUniqueInput
  update: territoriesUpdateWithoutRegionDataInput
  create: territoriesCreateWithoutRegionInput
}

export type territoriesUpdateManyWithoutRegionInput = {
  create?: Enumerable<territoriesCreateWithoutRegionInput>
  connect?: Enumerable<territoriesWhereUniqueInput>
  set?: Enumerable<territoriesWhereUniqueInput>
  disconnect?: Enumerable<territoriesWhereUniqueInput>
  delete?: Enumerable<territoriesWhereUniqueInput>
  update?: Enumerable<territoriesUpdateWithWhereUniqueWithoutRegionInput>
  updateMany?: Enumerable<territoriesUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<territoriesScalarWhereInput>
  upsert?: Enumerable<territoriesUpsertWithWhereUniqueWithoutRegionInput>
}

export type regionUpdateInput = {
  region_description?: string
  region_id?: number
  territories?: territoriesUpdateManyWithoutRegionInput
}

export type regionUpdateManyMutationInput = {
  region_description?: string
  region_id?: number
}

export type ordersCreateWithoutShippersInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput | null
  employees?: employeesCreateOneWithoutOrdersInput | null
  order_details?: order_detailsCreateManyWithoutOrdersInput | null
}

export type ordersCreateManyWithoutShippersInput = {
  create?: Enumerable<ordersCreateWithoutShippersInput>
  connect?: Enumerable<ordersWhereUniqueInput>
}

export type shippersCreateInput = {
  company_name: string
  phone?: string | null
  shipper_id: number
  orders?: ordersCreateManyWithoutShippersInput | null
}

export type ordersUpdateWithoutShippersDataInput = {
  freight?: number | null
  order_date?: Date | string | null
  order_id?: number
  required_date?: Date | string | null
  ship_address?: string | null
  ship_city?: string | null
  ship_country?: string | null
  ship_name?: string | null
  ship_postal_code?: string | null
  ship_region?: string | null
  shipped_date?: Date | string | null
  customers?: customersUpdateOneWithoutOrdersInput
  employees?: employeesUpdateOneWithoutOrdersInput
  order_details?: order_detailsUpdateManyWithoutOrdersInput
}

export type ordersUpdateWithWhereUniqueWithoutShippersInput = {
  where: ordersWhereUniqueInput
  data: ordersUpdateWithoutShippersDataInput
}

export type ordersUpsertWithWhereUniqueWithoutShippersInput = {
  where: ordersWhereUniqueInput
  update: ordersUpdateWithoutShippersDataInput
  create: ordersCreateWithoutShippersInput
}

export type ordersUpdateManyWithoutShippersInput = {
  create?: Enumerable<ordersCreateWithoutShippersInput>
  connect?: Enumerable<ordersWhereUniqueInput>
  set?: Enumerable<ordersWhereUniqueInput>
  disconnect?: Enumerable<ordersWhereUniqueInput>
  delete?: Enumerable<ordersWhereUniqueInput>
  update?: Enumerable<ordersUpdateWithWhereUniqueWithoutShippersInput>
  updateMany?: Enumerable<ordersUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<ordersScalarWhereInput>
  upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutShippersInput>
}

export type shippersUpdateInput = {
  company_name?: string
  phone?: string | null
  shipper_id?: number
  orders?: ordersUpdateManyWithoutShippersInput
}

export type shippersUpdateManyMutationInput = {
  company_name?: string
  phone?: string | null
  shipper_id?: number
}

export type productsCreateWithoutSuppliersInput = {
  discontinued: number
  product_id: number
  product_name: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  categories?: categoriesCreateOneWithoutProductsInput | null
  order_details?: order_detailsCreateManyWithoutProductsInput | null
}

export type productsCreateManyWithoutSuppliersInput = {
  create?: Enumerable<productsCreateWithoutSuppliersInput>
  connect?: Enumerable<productsWhereUniqueInput>
}

export type suppliersCreateInput = {
  address?: string | null
  city?: string | null
  company_name: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  fax?: string | null
  homepage?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  supplier_id: number
  products?: productsCreateManyWithoutSuppliersInput | null
}

export type productsUpdateWithoutSuppliersDataInput = {
  discontinued?: number
  product_id?: number
  product_name?: string
  quantity_per_unit?: string | null
  reorder_level?: number | null
  unit_price?: number | null
  units_in_stock?: number | null
  units_on_order?: number | null
  categories?: categoriesUpdateOneWithoutProductsInput
  order_details?: order_detailsUpdateManyWithoutProductsInput
}

export type productsUpdateWithWhereUniqueWithoutSuppliersInput = {
  where: productsWhereUniqueInput
  data: productsUpdateWithoutSuppliersDataInput
}

export type productsUpsertWithWhereUniqueWithoutSuppliersInput = {
  where: productsWhereUniqueInput
  update: productsUpdateWithoutSuppliersDataInput
  create: productsCreateWithoutSuppliersInput
}

export type productsUpdateManyWithoutSuppliersInput = {
  create?: Enumerable<productsCreateWithoutSuppliersInput>
  connect?: Enumerable<productsWhereUniqueInput>
  set?: Enumerable<productsWhereUniqueInput>
  disconnect?: Enumerable<productsWhereUniqueInput>
  delete?: Enumerable<productsWhereUniqueInput>
  update?: Enumerable<productsUpdateWithWhereUniqueWithoutSuppliersInput>
  updateMany?: Enumerable<productsUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<productsScalarWhereInput>
  upsert?: Enumerable<productsUpsertWithWhereUniqueWithoutSuppliersInput>
}

export type suppliersUpdateInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  fax?: string | null
  homepage?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  supplier_id?: number
  products?: productsUpdateManyWithoutSuppliersInput
}

export type suppliersUpdateManyMutationInput = {
  address?: string | null
  city?: string | null
  company_name?: string
  contact_name?: string | null
  contact_title?: string | null
  country?: string | null
  fax?: string | null
  homepage?: string | null
  phone?: string | null
  postal_code?: string | null
  region?: string | null
  supplier_id?: number
}

export type territoriesCreateInput = {
  territory_description: string
  territory_id: string
  region: regionCreateOneWithoutTerritoriesInput
  employee_territories?: employee_territoriesCreateManyWithoutTerritoriesInput | null
}

export type territoriesUpdateInput = {
  territory_description?: string
  territory_id?: string
  region?: regionUpdateOneRequiredWithoutTerritoriesInput
  employee_territories?: employee_territoriesUpdateManyWithoutTerritoriesInput
}

export type territoriesUpdateManyMutationInput = {
  territory_description?: string
  territory_id?: string
}

export type us_statesCreateInput = {
  state_abbr?: string | null
  state_id: number
  state_name?: string | null
  state_region?: string | null
}

export type us_statesUpdateInput = {
  state_abbr?: string | null
  state_id?: number
  state_name?: string | null
  state_region?: string | null
}

export type us_statesUpdateManyMutationInput = {
  state_abbr?: string | null
  state_id?: number
  state_name?: string | null
  state_region?: string | null
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type StringFilter = {
  equals?: string
  not?: string | StringFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type IntFilter = {
  equals?: number
  not?: number | IntFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type productsFilter = {
  every?: productsWhereInput
  some?: productsWhereInput
  none?: productsWhereInput
}

export type customer_customer_demoFilter = {
  every?: customer_customer_demoWhereInput
  some?: customer_customer_demoWhereInput
  none?: customer_customer_demoWhereInput
}

export type ordersFilter = {
  every?: ordersWhereInput
  some?: ordersWhereInput
  none?: ordersWhereInput
}

export type territoriesFilter = {
  every?: territoriesWhereInput
  some?: territoriesWhereInput
  none?: territoriesWhereInput
}

export type employee_territoriesFilter = {
  every?: employee_territoriesWhereInput
  some?: employee_territoriesWhereInput
  none?: employee_territoriesWhereInput
}

export type NullableDateTimeFilter = {
  equals?: Date | string | null
  not?: Date | string | null | NullableDateTimeFilter
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
}

export type NullableIntFilter = {
  equals?: number | null
  not?: number | null | NullableIntFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type employeesFilter = {
  every?: employeesWhereInput
  some?: employeesWhereInput
  none?: employeesWhereInput
}

export type NullableFloatFilter = {
  equals?: number | null
  not?: number | null | NullableFloatFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type order_detailsFilter = {
  every?: order_detailsWhereInput
  some?: order_detailsWhereInput
  none?: order_detailsWhereInput
}

export type FloatFilter = {
  equals?: number
  not?: number | FloatFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type categoriesOrderByInput = {
  category_id?: OrderByArg | null
  category_name?: OrderByArg | null
  description?: OrderByArg | null
}

export type productsOrderByInput = {
  category_id?: OrderByArg | null
  discontinued?: OrderByArg | null
  product_id?: OrderByArg | null
  product_name?: OrderByArg | null
  quantity_per_unit?: OrderByArg | null
  reorder_level?: OrderByArg | null
  supplier_id?: OrderByArg | null
  unit_price?: OrderByArg | null
  units_in_stock?: OrderByArg | null
  units_on_order?: OrderByArg | null
}

export type order_detailsOrderByInput = {
  discount?: OrderByArg | null
  order_id?: OrderByArg | null
  product_id?: OrderByArg | null
  quantity?: OrderByArg | null
  unit_price?: OrderByArg | null
}

export type customer_customer_demoOrderByInput = {
  customer_id?: OrderByArg | null
  customer_type_id?: OrderByArg | null
}

export type ordersOrderByInput = {
  customer_id?: OrderByArg | null
  employee_id?: OrderByArg | null
  freight?: OrderByArg | null
  order_date?: OrderByArg | null
  order_id?: OrderByArg | null
  required_date?: OrderByArg | null
  ship_address?: OrderByArg | null
  ship_city?: OrderByArg | null
  ship_country?: OrderByArg | null
  ship_name?: OrderByArg | null
  ship_postal_code?: OrderByArg | null
  ship_region?: OrderByArg | null
  ship_via?: OrderByArg | null
  shipped_date?: OrderByArg | null
}

export type employee_territoriesOrderByInput = {
  employee_id?: OrderByArg | null
  territory_id?: OrderByArg | null
}

export type territoriesOrderByInput = {
  region_id?: OrderByArg | null
  territory_description?: OrderByArg | null
  territory_id?: OrderByArg | null
}

export type employeesOrderByInput = {
  address?: OrderByArg | null
  birth_date?: OrderByArg | null
  city?: OrderByArg | null
  country?: OrderByArg | null
  employee_id?: OrderByArg | null
  extension?: OrderByArg | null
  first_name?: OrderByArg | null
  hire_date?: OrderByArg | null
  home_phone?: OrderByArg | null
  last_name?: OrderByArg | null
  notes?: OrderByArg | null
  photo_path?: OrderByArg | null
  postal_code?: OrderByArg | null
  region?: OrderByArg | null
  reports_to?: OrderByArg | null
  title?: OrderByArg | null
  title_of_courtesy?: OrderByArg | null
}

export type customer_demographicsOrderByInput = {
  customer_desc?: OrderByArg | null
  customer_type_id?: OrderByArg | null
}

export type customersOrderByInput = {
  address?: OrderByArg | null
  city?: OrderByArg | null
  company_name?: OrderByArg | null
  contact_name?: OrderByArg | null
  contact_title?: OrderByArg | null
  country?: OrderByArg | null
  customer_id?: OrderByArg | null
  fax?: OrderByArg | null
  phone?: OrderByArg | null
  postal_code?: OrderByArg | null
  region?: OrderByArg | null
}

export type regionOrderByInput = {
  region_description?: OrderByArg | null
  region_id?: OrderByArg | null
}

export type shippersOrderByInput = {
  company_name?: OrderByArg | null
  phone?: OrderByArg | null
  shipper_id?: OrderByArg | null
}

export type suppliersOrderByInput = {
  address?: OrderByArg | null
  city?: OrderByArg | null
  company_name?: OrderByArg | null
  contact_name?: OrderByArg | null
  contact_title?: OrderByArg | null
  country?: OrderByArg | null
  fax?: OrderByArg | null
  homepage?: OrderByArg | null
  phone?: OrderByArg | null
  postal_code?: OrderByArg | null
  region?: OrderByArg | null
  supplier_id?: OrderByArg | null
}

export type us_statesOrderByInput = {
  state_abbr?: OrderByArg | null
  state_id?: OrderByArg | null
  state_name?: OrderByArg | null
  state_region?: OrderByArg | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
